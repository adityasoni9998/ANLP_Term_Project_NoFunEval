{
	"non_functional_requirement": "executiontime",
	"commit": "https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/0eb3cc570e3898cf681d12cf399ab040aea16e8f",
	"commit_message": "'\\\\\"For larger scans a fixed thread pool provides better performance\\\\n\\\\\"'",
	"source_code": "package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newCachedThreadPool();\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n",
	"target_code": "package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n",
	"pl": "Java",
	"classification_left_label": "A",
	"classification_right_label": "B",
	"left_output": "A",
	"right_output": "A"
}