{
	"non_functional_requirement": "executiontime",
	"commit": "https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/0eb3cc570e3898cf681d12cf399ab040aea16e8f",
	"commit_message": "'\\\\\"For larger scans a fixed thread pool provides better performance\\\\n\\\\\"'",
	"source_code": "package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newCachedThreadPool();\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n",
	"target_code": "package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n",
	"pl": "Java",
	"classification_left_prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                Socket socket = new Socket();\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-",
	"classification_left_label": "A",
	"classification_right_prompt": "Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                Socket socket = new Socket();\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-",
	"classification_right_label": "B",
	"inference_time": 1.5405637,
	"generated_answers": [
		"Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the code to improve execution time for larger scans. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] Fixed size thread pool\n[in] doInBackground function\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newCachedThreadPool();\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n\n```\n\n### Response:\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n```"
	]
}