{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/b311d3140b4845eb56d20a40c4577f14c05d2404","commit_message":"'\\\\\"Avoid potential resource leak\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.network;\n\nimport android.app.Activity;\nimport android.database.Cursor;\n\nimport com.aaronjwood.portauthority.async.ScanPortsAsyncTask;\nimport com.aaronjwood.portauthority.db.Database;\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\npublic class Host {\n\n    \/**\n     * Starts a port scan\n     *\n     * @param ip        IP address\n     * @param startPort The port to start scanning at\n     * @param stopPort  The port to stop scanning at\n     * @param delegate  Delegate to be called when the port scan has finished\n     *\/\n    public void scanPorts(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        new ScanPortsAsyncTask(delegate).execute(ip, startPort, stopPort);\n    }\n\n    \/**\n     * Fetches the MAC vendor from the database\n     *\n     * @param mac      MAC address\n     * @param activity The calling activity\n     *\/\n    public String getMacVendor(String mac, Activity activity) {\n        Database db = new Database(activity);\n        Cursor cursor = db.queryDatabase(\"oui.db\", \"SELECT vendor FROM oui WHERE mac LIKE ?\", new String[]{mac});\n        if (cursor != null && cursor.moveToFirst()) {\n            String value = cursor.getString(cursor.getColumnIndex(\"vendor\"));\n            cursor.close();\n            db.close();\n            return value;\n        } else {\n            return \"Vendor not in database\";\n        }\n    }\n\n}\n","target_code":"package com.aaronjwood.portauthority.network;\n\nimport android.app.Activity;\nimport android.database.Cursor;\n\nimport com.aaronjwood.portauthority.async.ScanPortsAsyncTask;\nimport com.aaronjwood.portauthority.db.Database;\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\npublic class Host {\n\n    \/**\n     * Starts a port scan\n     *\n     * @param ip        IP address\n     * @param startPort The port to start scanning at\n     * @param stopPort  The port to stop scanning at\n     * @param delegate  Delegate to be called when the port scan has finished\n     *\/\n    public void scanPorts(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        new ScanPortsAsyncTask(delegate).execute(ip, startPort, stopPort);\n    }\n\n    \/**\n     * Fetches the MAC vendor from the database\n     *\n     * @param mac      MAC address\n     * @param activity The calling activity\n     *\/\n    public String getMacVendor(String mac, Activity activity) {\n        Database db = new Database(activity);\n        Cursor cursor = db.queryDatabase(\"oui.db\", \"SELECT vendor FROM oui WHERE mac LIKE ?\", new String[]{mac});\n        String vendor;\n\n        try {\n            if (cursor != null && cursor.moveToFirst()) {\n                vendor = cursor.getString(cursor.getColumnIndex(\"vendor\"));\n            } else {\n                vendor = \"Vendor not in database\";\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n                db.close();\n            }\n        }\n\n        return vendor;\n    }\n\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage be.digitalia.fosdem.fragments;\n\nimport android.os.Build;\nimport android.support.v4.app.ListFragment;\n\n\/**\n * ListFragment which disables the fade animation under certain conditions for more smoothness.\n *\/\npublic class SmoothListFragment extends ListFragment {\n\n\t@Override\n\tpublic void setListShown(boolean shown) {\n\t\tif ((Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) && isResumed()) {\n\t\t\tsuper.setListShown(shown);\n\t\t} else {\n\t\t\tsetListShownNoAnimation(shown);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onDestroyView() {\n\t\t\/\/ Ensure the ListView is properly unregistered as an observer of the adapter\n\t\tgetListView().setAdapter(null);\n\t\tsuper.onDestroyView();\n\t}\n}\n\n\nCode-B:\npackage be.digitalia.fosdem.fragments;\n\nimport android.os.Build;\nimport android.support.v4.app.ListFragment;\n\n\/**\n * ListFragment which disables the fade animation under certain conditions for more smoothness.\n *\/\npublic class SmoothListFragment extends ListFragment {\n\n\t@Override\n\tpublic void setListShown(boolean shown) {\n\t\tif ((Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) && isResumed()) {\n\t\t\tsuper.setListShown(shown);\n\t\t} else {\n\t\t\tsetListShownNoAnimation(shown);\n\t\t}\n\t}\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage be.digitalia.fosdem.fragments;\n\nimport android.os.Build;\nimport android.support.v4.app.ListFragment;\n\n\/**\n * ListFragment which disables the fade animation under certain conditions for more smoothness.\n *\/\npublic class SmoothListFragment extends ListFragment {\n\n\t@Override\n\tpublic void setListShown(boolean shown) {\n\t\tif ((Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) && isResumed()) {\n\t\t\tsuper.setListShown(shown);\n\t\t} else {\n\t\t\tsetListShownNoAnimation(shown);\n\t\t}\n\t}\n}\n\n\nCode-B:\npackage be.digitalia.fosdem.fragments;\n\nimport android.os.Build;\nimport android.support.v4.app.ListFragment;\n\n\/**\n * ListFragment which disables the fade animation under certain conditions for more smoothness.\n *\/\npublic class SmoothListFragment extends ListFragment {\n\n\t@Override\n\tpublic void setListShown(boolean shown) {\n\t\tif ((Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) && isResumed()) {\n\t\t\tsuper.setListShown(shown);\n\t\t} else {\n\t\t\tsetListShownNoAnimation(shown);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onDestroyView() {\n\t\t\/\/ Ensure the ListView is properly unregistered as an observer of the adapter\n\t\tgetListView().setAdapter(null);\n\t\tsuper.onDestroyView();\n\t}\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nAvoid potential resource leaks in the code. Write the entire code and no other text in the response.\n\n### Concepts:\n[in] getMacVendor function\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.network;\n\nimport android.app.Activity;\nimport android.database.Cursor;\n\nimport com.aaronjwood.portauthority.async.ScanPortsAsyncTask;\nimport com.aaronjwood.portauthority.db.Database;\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\npublic class Host {\n\n    \/**\n     * Starts a port scan\n     *\n     * @param ip        IP address\n     * @param startPort The port to start scanning at\n     * @param stopPort  The port to stop scanning at\n     * @param delegate  Delegate to be called when the port scan has finished\n     *\/\n    public void scanPorts(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        new ScanPortsAsyncTask(delegate).execute(ip, startPort, stopPort);\n    }\n\n    \/**\n     * Fetches the MAC vendor from the database\n     *\n     * @param mac      MAC address\n     * @param activity The calling activity\n     *\/\n    public String getMacVendor(String mac, Activity activity) {\n        Database db = new Database(activity);\n        Cursor cursor = db.queryDatabase(\"oui.db\", \"SELECT vendor FROM oui WHERE mac LIKE ?\", new String[]{mac});\n        String vendor;\n\n        try {\n            if (cursor != null && cursor.moveToFirst()) {\n                vendor = cursor.getString(cursor.getColumnIndex(\"vendor\"));\n            } else {\n                vendor = \"Vendor not in database\";\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n                db.close();\n            }\n        }\n\n        return vendor;\n    }\n\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.network;\n\nimport android.app.Activity;\nimport android.database.Cursor;\n\nimport com.aaronjwood.portauthority.async.ScanPortsAsyncTask;\nimport com.aaronjwood.portauthority.db.Database;\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\npublic class Host {\n\n    \/**\n     * Starts a port scan\n     *\n     * @param ip        IP address\n     * @param startPort The port to start scanning at\n     * @param stopPort  The port to stop scanning at\n     * @param delegate  Delegate to be called when the port scan has finished\n     *\/\n    public void scanPorts(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        new ScanPortsAsyncTask(delegate).execute(ip, startPort, stopPort);\n    }\n\n    \/**\n     * Fetches the MAC vendor from the database\n     *\n     * @param mac      MAC address\n     * @param activity The calling activity\n     *\/\n    public String getMacVendor(String mac, Activity activity) {\n        Database db = new Database(activity);\n        Cursor cursor = null;\n        String vendor;\n\n        try {\n            cursor = db.queryDatabase(\"oui.db\", \"SELECT vendor FROM oui WHERE mac LIKE ?\", new String[]{mac});\n            if (cursor != null && cursor.moveToFirst()) {\n                vendor = cursor.getString(cursor.getColumnIndex(\"vendor\"));\n            } else {\n                vendor = \"Vendor not in database\";\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n            db.close();\n        }\n\n        return vendor;\n    }\n\n}\n```"]}
{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/adc73aac9c7dba5c61e1e18a96dfe7dd9712d100","commit_message":"'\\\\\"Fix resource leak\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 150);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}","target_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 150);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower energy usage.\n\nCode-A:\n\n\/\/ 20 seconds in milliseconds\nvar measurementIntervalMs = 20000;\n\nvar keen = require('keen.io');\nvar SensorTag = require('sensortag');\n\nvar keen = keen.configure({\n    projectId: process.env.keen_io_projectId,\n    writeKey: process.env.keen_io_writeKey\n});\n\nvar uuid = process.env.sensortag_uuid;\n\nfunction send_to_keenio(temperature,humidity,uuid) {\n    console.log(uuid + ' \\ttemperature = %d \u00b0C', temperature);\n    console.log(uuid + ' \\thumidity = %d %', humidity);\n\n    var eventdata = {};\n    eventdata[\"SensorTag \" + uuid] = [\n\t{\n            \"temperature\": temperature,\n            \"humidity\": humidity\n        }\n    ];\n    keen.addEvents(eventdata, function(err, res) {\n\tif (err) {\n\t    console.log(\"Error sending to keen \" + err + res);\n\t}\n    });\n};\n\nconsole.log('Init, discover uuids ' + uuid);\nSensorTag.discover(function(sensorTag) {\n    var uuid = sensorTag.uuid;\n    console.log(uuid + ' Discovered');\n    sensorTag.connect(function() {\n\tconsole.log(uuid + ' Connected');\n\tsensorTag.discoverServicesAndCharacteristics(function() {\n\t    console.log(uuid + ' DiscoverServicesAndCharacteristics');\n\t    sensorTag.on('humidityChange', function(temperature, humidity) {\n\t\t\/\/ Ignore readings of a disabled sensor\n\t\tif (temperature == -46.85 && humidity == -6) {\n\t\t    return;\n\t\t}\n\t\tvar temp = temperature.toFixed(2);\n\t\tvar hum = humidity.toFixed(2);\n\t\tsensorTag.disableHumidity(function() {\n\t\t    console.log(uuid + ' Got reading, humidity sensor disabled for ' + measurementIntervalMs + ' ms');\n\t\t});\n\t\tsend_to_keenio(temp,hum,uuid);\n\t    });\n\t    \n\t    setInterval(function() {\n\t\tsensorTag.enableHumidity(function() {\n\t\t    console.log(uuid + ' Humidity sensor enabled to get the next reading');\n\t\t});\n\t    }, measurementIntervalMs);\n\t    \n\t    sensorTag.notifyHumidity(function() {\n\t\tconsole.log(uuid + ' Humidity notifications enabled');\n\t    });\n\t});\n    });\n}, uuid);\n\n\n\n\nCode-B:\nvar keen = require('keen.io');\nvar SensorTag = require('sensortag');\n\nvar keen = keen.configure({\n    projectId: process.env.keen_io_projectId,\n    writeKey: process.env.keen_io_writeKey\n});\n\nvar uuid = process.env.sensortag_uuid;\n\nfunction send_to_keenio(temperature,humidity,uuid) {\n    console.log(uuid + '\\ttemperature = %d \u00b0C', temperature.toFixed(1));\n    console.log(uuid + '\\thumidity = %d %', humidity.toFixed(1));\n    console.log(\"\");\n\n    var eventdata = {};\n    eventdata[\"SensorTag \" + uuid] = [\n\t{\n            \"temperature\": temperature.toFixed(1),\n            \"humidity\": humidity.toFixed(1)\n        }\n    ];\n    keen.addEvents(eventdata, function(err, res) {\n\tif (err) {\n\t    console.log(\"Error sending to keen \" + err + res);\n\t}\n    });\n};\n\nconsole.log('Init, discover uuids ' + uuid);\nSensorTag.discover(function(sensorTag) {\n    var uuid = sensorTag.uuid;\n    console.log(uuid + ' Discovered');\n    sensorTag.connect(function() {\n\tconsole.log(uuid + ' Connected');\n\tsensorTag.discoverServicesAndCharacteristics(function() {\n\t    console.log(uuid + ' discoverServicesAndCharacteristics');\n            sensorTag.enableHumidity(function() {\n\t\tconsole.log(uuid + ' Humidity sensor enabled');\n\t\tsensorTag.on('humidityChange', function(temperature, humidity) {\n\t\t    send_to_keenio(temperature,humidity,uuid);\n\t\t});\n\t\t\n\t\tsensorTag.notifyHumidity(function() {\n\t\t    console.log(uuid + 'Humidity notifications enabled');\n\t\t});\n\t    });\n\t});\n    });\n}, uuid);\n\n\n\n\nPlease select the code snippet from Code-A or Code-B with a lower energy usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower energy usage.\n\nCode-A:\nvar keen = require('keen.io');\nvar SensorTag = require('sensortag');\n\nvar keen = keen.configure({\n    projectId: process.env.keen_io_projectId,\n    writeKey: process.env.keen_io_writeKey\n});\n\nvar uuid = process.env.sensortag_uuid;\n\nfunction send_to_keenio(temperature,humidity,uuid) {\n    console.log(uuid + '\\ttemperature = %d \u00b0C', temperature.toFixed(1));\n    console.log(uuid + '\\thumidity = %d %', humidity.toFixed(1));\n    console.log(\"\");\n\n    var eventdata = {};\n    eventdata[\"SensorTag \" + uuid] = [\n\t{\n            \"temperature\": temperature.toFixed(1),\n            \"humidity\": humidity.toFixed(1)\n        }\n    ];\n    keen.addEvents(eventdata, function(err, res) {\n\tif (err) {\n\t    console.log(\"Error sending to keen \" + err + res);\n\t}\n    });\n};\n\nconsole.log('Init, discover uuids ' + uuid);\nSensorTag.discover(function(sensorTag) {\n    var uuid = sensorTag.uuid;\n    console.log(uuid + ' Discovered');\n    sensorTag.connect(function() {\n\tconsole.log(uuid + ' Connected');\n\tsensorTag.discoverServicesAndCharacteristics(function() {\n\t    console.log(uuid + ' discoverServicesAndCharacteristics');\n            sensorTag.enableHumidity(function() {\n\t\tconsole.log(uuid + ' Humidity sensor enabled');\n\t\tsensorTag.on('humidityChange', function(temperature, humidity) {\n\t\t    send_to_keenio(temperature,humidity,uuid);\n\t\t});\n\t\t\n\t\tsensorTag.notifyHumidity(function() {\n\t\t    console.log(uuid + 'Humidity notifications enabled');\n\t\t});\n\t    });\n\t});\n    });\n}, uuid);\n\n\n\n\nCode-B:\n\n\/\/ 20 seconds in milliseconds\nvar measurementIntervalMs = 20000;\n\nvar keen = require('keen.io');\nvar SensorTag = require('sensortag');\n\nvar keen = keen.configure({\n    projectId: process.env.keen_io_projectId,\n    writeKey: process.env.keen_io_writeKey\n});\n\nvar uuid = process.env.sensortag_uuid;\n\nfunction send_to_keenio(temperature,humidity,uuid) {\n    console.log(uuid + ' \\ttemperature = %d \u00b0C', temperature);\n    console.log(uuid + ' \\thumidity = %d %', humidity);\n\n    var eventdata = {};\n    eventdata[\"SensorTag \" + uuid] = [\n\t{\n            \"temperature\": temperature,\n            \"humidity\": humidity\n        }\n    ];\n    keen.addEvents(eventdata, function(err, res) {\n\tif (err) {\n\t    console.log(\"Error sending to keen \" + err + res);\n\t}\n    });\n};\n\nconsole.log('Init, discover uuids ' + uuid);\nSensorTag.discover(function(sensorTag) {\n    var uuid = sensorTag.uuid;\n    console.log(uuid + ' Discovered');\n    sensorTag.connect(function() {\n\tconsole.log(uuid + ' Connected');\n\tsensorTag.discoverServicesAndCharacteristics(function() {\n\t    console.log(uuid + ' DiscoverServicesAndCharacteristics');\n\t    sensorTag.on('humidityChange', function(temperature, humidity) {\n\t\t\/\/ Ignore readings of a disabled sensor\n\t\tif (temperature == -46.85 && humidity == -6) {\n\t\t    return;\n\t\t}\n\t\tvar temp = temperature.toFixed(2);\n\t\tvar hum = humidity.toFixed(2);\n\t\tsensorTag.disableHumidity(function() {\n\t\t    console.log(uuid + ' Got reading, humidity sensor disabled for ' + measurementIntervalMs + ' ms');\n\t\t});\n\t\tsend_to_keenio(temp,hum,uuid);\n\t    });\n\t    \n\t    setInterval(function() {\n\t\tsensorTag.enableHumidity(function() {\n\t\t    console.log(uuid + ' Humidity sensor enabled to get the next reading');\n\t\t});\n\t    }, measurementIntervalMs);\n\t    \n\t    sensorTag.notifyHumidity(function() {\n\t\tconsole.log(uuid + ' Humidity notifications enabled');\n\t    });\n\t});\n    });\n}, uuid);\n\n\n\n\nPlease select the code snippet from Code-A or Code-B with a lower energy usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nFix potential resource leaks in the code. Write the entire code and no other text in the response.\n\n### Concepts:\n[in] run function\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 150);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try (Socket socket = new Socket()) {\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 150);\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n```"]}
{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/09245734d529978ee1219f08cee932af44d47d39","commit_message":"'\\\\\"Fix memory leak\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\n\npublic class GetExternalIpAsyncTask extends AsyncTask<Void, Void, String> {\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/ipinfo.io\/ip\";\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public GetExternalIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(EXTERNAL_IP_SERVICE);\n\n        try {\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            return EntityUtils.toString(entity).trim();\n        }\n        catch(ClientProtocolException e) {\n            return \"Couldn't get your external IP\";\n        }\n        catch(IOException e) {\n            return \"Couldn't get your external IP\";\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        delegate.processFinish(result);\n    }\n}\n","target_code":"package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\npublic class GetExternalIpAsyncTask extends AsyncTask<Void, Void, String> {\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/ipinfo.io\/ip\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public GetExternalIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(EXTERNAL_IP_SERVICE);\n\n        try {\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            return EntityUtils.toString(entity).trim();\n        } catch (ClientProtocolException e) {\n            return \"Couldn't get your external IP\";\n        } catch (IOException e) {\n            return \"Couldn't get your external IP\";\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.network;\n\nimport android.app.Activity;\nimport android.database.Cursor;\n\nimport com.aaronjwood.portauthority.async.ScanPortsAsyncTask;\nimport com.aaronjwood.portauthority.db.Database;\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\npublic class Host {\n\n    \/**\n     * Starts a port scan\n     *\n     * @param ip        IP address\n     * @param startPort The port to start scanning at\n     * @param stopPort  The port to stop scanning at\n     * @param delegate  Delegate to be called when the port scan has finished\n     *\/\n    public void scanPorts(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        new ScanPortsAsyncTask(delegate).execute(ip, startPort, stopPort);\n    }\n\n    \/**\n     * Fetches the MAC vendor from the database\n     *\n     * @param mac      MAC address\n     * @param activity The calling activity\n     *\/\n    public String getMacVendor(String mac, Activity activity) {\n        Database db = new Database(activity);\n        Cursor cursor = db.queryDatabase(\"oui.db\", \"SELECT vendor FROM oui WHERE mac LIKE ?\", new String[]{mac});\n        String vendor;\n\n        try {\n            if (cursor != null && cursor.moveToFirst()) {\n                vendor = cursor.getString(cursor.getColumnIndex(\"vendor\"));\n            } else {\n                vendor = \"Vendor not in database\";\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n                db.close();\n            }\n        }\n\n        return vendor;\n    }\n\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.network;\n\nimport android.app.Activity;\nimport android.database.Cursor;\n\nimport com.aaronjwood.portauthority.async.ScanPortsAsyncTask;\nimport com.aaronjwood.portauthority.db.Database;\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\npublic class Host {\n\n    \/**\n     * Starts a port scan\n     *\n     * @param ip        IP address\n     * @param startPort The port to start scanning at\n     * @param stopPort  The port to stop scanning at\n     * @param delegate  Delegate to be called when the port scan has finished\n     *\/\n    public void scanPorts(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        new ScanPortsAsyncTask(delegate).execute(ip, startPort, stopPort);\n    }\n\n    \/**\n     * Fetches the MAC vendor from the database\n     *\n     * @param mac      MAC address\n     * @param activity The calling activity\n     *\/\n    public String getMacVendor(String mac, Activity activity) {\n        Database db = new Database(activity);\n        Cursor cursor = db.queryDatabase(\"oui.db\", \"SELECT vendor FROM oui WHERE mac LIKE ?\", new String[]{mac});\n        if (cursor != null && cursor.moveToFirst()) {\n            String value = cursor.getString(cursor.getColumnIndex(\"vendor\"));\n            cursor.close();\n            db.close();\n            return value;\n        } else {\n            return \"Vendor not in database\";\n        }\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.network;\n\nimport android.app.Activity;\nimport android.database.Cursor;\n\nimport com.aaronjwood.portauthority.async.ScanPortsAsyncTask;\nimport com.aaronjwood.portauthority.db.Database;\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\npublic class Host {\n\n    \/**\n     * Starts a port scan\n     *\n     * @param ip        IP address\n     * @param startPort The port to start scanning at\n     * @param stopPort  The port to stop scanning at\n     * @param delegate  Delegate to be called when the port scan has finished\n     *\/\n    public void scanPorts(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        new ScanPortsAsyncTask(delegate).execute(ip, startPort, stopPort);\n    }\n\n    \/**\n     * Fetches the MAC vendor from the database\n     *\n     * @param mac      MAC address\n     * @param activity The calling activity\n     *\/\n    public String getMacVendor(String mac, Activity activity) {\n        Database db = new Database(activity);\n        Cursor cursor = db.queryDatabase(\"oui.db\", \"SELECT vendor FROM oui WHERE mac LIKE ?\", new String[]{mac});\n        if (cursor != null && cursor.moveToFirst()) {\n            String value = cursor.getString(cursor.getColumnIndex(\"vendor\"));\n            cursor.close();\n            db.close();\n            return value;\n        } else {\n            return \"Vendor not in database\";\n        }\n    }\n\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.network;\n\nimport android.app.Activity;\nimport android.database.Cursor;\n\nimport com.aaronjwood.portauthority.async.ScanPortsAsyncTask;\nimport com.aaronjwood.portauthority.db.Database;\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\npublic class Host {\n\n    \/**\n     * Starts a port scan\n     *\n     * @param ip        IP address\n     * @param startPort The port to start scanning at\n     * @param stopPort  The port to stop scanning at\n     * @param delegate  Delegate to be called when the port scan has finished\n     *\/\n    public void scanPorts(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        new ScanPortsAsyncTask(delegate).execute(ip, startPort, stopPort);\n    }\n\n    \/**\n     * Fetches the MAC vendor from the database\n     *\n     * @param mac      MAC address\n     * @param activity The calling activity\n     *\/\n    public String getMacVendor(String mac, Activity activity) {\n        Database db = new Database(activity);\n        Cursor cursor = db.queryDatabase(\"oui.db\", \"SELECT vendor FROM oui WHERE mac LIKE ?\", new String[]{mac});\n        String vendor;\n\n        try {\n            if (cursor != null && cursor.moveToFirst()) {\n                vendor = cursor.getString(cursor.getColumnIndex(\"vendor\"));\n            } else {\n                vendor = \"Vendor not in database\";\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n                db.close();\n            }\n        }\n\n        return vendor;\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nFix potential memory leaks in the code. Write the entire code and no other text in the response.\n\n### Concepts:\n[in] onPostExecution function\n[+] java.lang.ref.WeakReference\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\npublic class GetExternalIpAsyncTask extends AsyncTask<Void, Void, String> {\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/ipinfo.io\/ip\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public GetExternalIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(EXTERNAL_IP_SERVICE);\n\n        try {\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            return EntityUtils.toString(entity).trim();\n        } catch (ClientProtocolException e) {\n            return \"Couldn't get your external IP\";\n        } catch (IOException e) {\n            return \"Couldn't get your external IP\";\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\npublic class GetExternalIpAsyncTask extends AsyncTask<Void, Void, String> {\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/ipinfo.io\/ip\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public GetExternalIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(EXTERNAL_IP_SERVICE);\n\n        try {\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            return EntityUtils.toString(entity).trim();\n        } catch (ClientProtocolException e) {\n            return \"Couldn't get your external IP\";\n        } catch (IOException e) {\n            return \"Couldn't get your external IP\";\n        } finally {\n            httpclient.getConnectionManager().shutdown();\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n```"]}
{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/05cc3dfaf15a63f9b4e6a16858665e5fbbe294f0","commit_message":"'\\\\\"Fix resource leak in certain cases\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class WanIpAsyncTask extends AsyncTask<Void, Void, String> {\n\n    \/\/ IP service is 100% open source https:\/\/github.com\/aaronjwood\/public-ip-api\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/public-ip-api.appspot.com\/\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public WanIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        String error = \"Couldn't get your external IP\";\n        OkHttpClient httpClient = new OkHttpClient();\n        Request request = new Request.Builder().url(EXTERNAL_IP_SERVICE).build();\n\n        try {\n            Response response = httpClient.newCall(request).execute();\n            if (!response.isSuccessful()) {\n                return error;\n            }\n\n            return response.body().string().trim();\n        } catch (IOException e) {\n            return error;\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n","target_code":"package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\npublic class WanIpAsyncTask extends AsyncTask<Void, Void, String> {\n\n    \/\/ IP service is 100% open source https:\/\/github.com\/aaronjwood\/public-ip-api\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/public-ip-api.appspot.com\/\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public WanIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        String error = \"Couldn't get your external IP\";\n        OkHttpClient httpClient = new OkHttpClient();\n        Request request = new Request.Builder().url(EXTERNAL_IP_SERVICE).build();\n\n        try {\n            Response response = httpClient.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (!response.isSuccessful()) {\n                body.close();\n                return error;\n            }\n\n            return response.body().string().trim(); \/\/ string() closes the resource automatically.\n        } catch (IOException e) {\n            return error;\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 150);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 150);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 150);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 150);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nFix potential memory leaks in the code. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] okhttp3.ResponseBody\n[in] response.body function\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\npublic class WanIpAsyncTask extends AsyncTask<Void, Void, String> {\n\n    \/\/ IP service is 100% open source https:\/\/github.com\/aaronjwood\/public-ip-api\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/public-ip-api.appspot.com\/\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public WanIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        String error = \"Couldn't get your external IP\";\n        OkHttpClient httpClient = new OkHttpClient();\n        Request request = new Request.Builder().url(EXTERNAL_IP_SERVICE).build();\n\n        try {\n            Response response = httpClient.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (!response.isSuccessful()) {\n                body.close();\n                return error;\n            }\n\n            return response.body().string().trim(); \/\/ string() closes the resource automatically.\n        } catch (IOException e) {\n            return error;\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\npublic class WanIpAsyncTask extends AsyncTask<Void, Void, String> {\n\n    \/\/ IP service is 100% open source https:\/\/github.com\/aaronjwood\/public-ip-api\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/public-ip-api.appspot.com\/\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public WanIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        String error = \"Couldn't get your external IP\";\n        OkHttpClient httpClient = new OkHttpClient();\n        Request request = new Request.Builder().url(EXTERNAL_IP_SERVICE).build();\n\n        try (Response response = httpClient.newCall(request).execute()) {\n            ResponseBody body = response.body();\n            if (!response.isSuccessful() || body == null) {\n                return error;\n            }\n\n            return body.string().trim(); \/\/ string() closes the resource automatically.\n        } catch (IOException e) {\n            return error;\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n```"]}
{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/vaginessa\/TestBrowser-Lightning\/commit\/15cb950af368a474e880671e12656bbebb131dcf","commit_message":"'\\\\\"Fixed a memory leak\\\\n\\\\\"'","source_code":"package acr.browser.lightning.search;\n\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.anthonycr.bonsai.Action;\nimport com.anthonycr.bonsai.Observable;\nimport com.anthonycr.bonsai.Subscriber;\n\nimport java.util.List;\n\nimport acr.browser.lightning.app.BrowserApp;\nimport acr.browser.lightning.database.HistoryItem;\n\nclass SuggestionsManager {\n\n    public enum Source {\n        GOOGLE,\n        DUCK\n    }\n\n    private static volatile boolean sIsTaskExecuting;\n\n    static boolean isRequestInProgress() {\n        return sIsTaskExecuting;\n    }\n\n    static Observable<List<HistoryItem>> getObservable(@NonNull final String query, @NonNull final Context context, @NonNull final Source source) {\n        return Observable.create(new Action<List<HistoryItem>>() {\n            @Override\n            public void onSubscribe(@NonNull final Subscriber<List<HistoryItem>> subscriber) {\n                sIsTaskExecuting = true;\n                switch (source) {\n                    case GOOGLE:\n                        new GoogleSuggestionsTask(query, BrowserApp.get(context), new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                        break;\n                    case DUCK:\n                        new DuckSuggestionsTask(query, BrowserApp.get(context), new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                }\n                sIsTaskExecuting = false;\n            }\n        });\n    }\n\n}\n","target_code":"package acr.browser.lightning.search;\n\nimport android.app.Application;\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.anthonycr.bonsai.Action;\nimport com.anthonycr.bonsai.Observable;\nimport com.anthonycr.bonsai.Subscriber;\n\nimport java.util.List;\n\nimport acr.browser.lightning.app.BrowserApp;\nimport acr.browser.lightning.database.HistoryItem;\n\nclass SuggestionsManager {\n\n    public enum Source {\n        GOOGLE,\n        DUCK\n    }\n\n    private static volatile boolean sIsTaskExecuting;\n\n    static boolean isRequestInProgress() {\n        return sIsTaskExecuting;\n    }\n\n    static Observable<List<HistoryItem>> getObservable(@NonNull final String query, @NonNull final Context context, @NonNull final Source source) {\n        final Application application = BrowserApp.get(context);\n        return Observable.create(new Action<List<HistoryItem>>() {\n            @Override\n            public void onSubscribe(@NonNull final Subscriber<List<HistoryItem>> subscriber) {\n                sIsTaskExecuting = true;\n                switch (source) {\n                    case GOOGLE:\n                        new GoogleSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                        break;\n                    case DUCK:\n                        new DuckSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                }\n                sIsTaskExecuting = false;\n            }\n        });\n    }\n\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\npublic class GetExternalIpAsyncTask extends AsyncTask<Void, Void, String> {\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/ipinfo.io\/ip\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public GetExternalIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(EXTERNAL_IP_SERVICE);\n\n        try {\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            return EntityUtils.toString(entity).trim();\n        } catch (ClientProtocolException e) {\n            return \"Couldn't get your external IP\";\n        } catch (IOException e) {\n            return \"Couldn't get your external IP\";\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\n\npublic class GetExternalIpAsyncTask extends AsyncTask<Void, Void, String> {\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/ipinfo.io\/ip\";\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public GetExternalIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(EXTERNAL_IP_SERVICE);\n\n        try {\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            return EntityUtils.toString(entity).trim();\n        }\n        catch(ClientProtocolException e) {\n            return \"Couldn't get your external IP\";\n        }\n        catch(IOException e) {\n            return \"Couldn't get your external IP\";\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        delegate.processFinish(result);\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\n\npublic class GetExternalIpAsyncTask extends AsyncTask<Void, Void, String> {\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/ipinfo.io\/ip\";\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public GetExternalIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(EXTERNAL_IP_SERVICE);\n\n        try {\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            return EntityUtils.toString(entity).trim();\n        }\n        catch(ClientProtocolException e) {\n            return \"Couldn't get your external IP\";\n        }\n        catch(IOException e) {\n            return \"Couldn't get your external IP\";\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        delegate.processFinish(result);\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\npublic class GetExternalIpAsyncTask extends AsyncTask<Void, Void, String> {\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/ipinfo.io\/ip\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public GetExternalIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(EXTERNAL_IP_SERVICE);\n\n        try {\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            return EntityUtils.toString(entity).trim();\n        } catch (ClientProtocolException e) {\n            return \"Couldn't get your external IP\";\n        } catch (IOException e) {\n            return \"Couldn't get your external IP\";\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nFix potential memory leaks in the code. Write the entire code and no other text in the response.\n\n### Concepts:\n[in] getObservable function\n[+] import android.app.Application\n\n### Given program:\n```java\npackage acr.browser.lightning.search;\n\nimport android.app.Application;\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.anthonycr.bonsai.Action;\nimport com.anthonycr.bonsai.Observable;\nimport com.anthonycr.bonsai.Subscriber;\n\nimport java.util.List;\n\nimport acr.browser.lightning.app.BrowserApp;\nimport acr.browser.lightning.database.HistoryItem;\n\nclass SuggestionsManager {\n\n    public enum Source {\n        GOOGLE,\n        DUCK\n    }\n\n    private static volatile boolean sIsTaskExecuting;\n\n    static boolean isRequestInProgress() {\n        return sIsTaskExecuting;\n    }\n\n    static Observable<List<HistoryItem>> getObservable(@NonNull final String query, @NonNull final Context context, @NonNull final Source source) {\n        final Application application = BrowserApp.get(context);\n        return Observable.create(new Action<List<HistoryItem>>() {\n            @Override\n            public void onSubscribe(@NonNull final Subscriber<List<HistoryItem>> subscriber) {\n                sIsTaskExecuting = true;\n                switch (source) {\n                    case GOOGLE:\n                        new GoogleSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                        break;\n                    case DUCK:\n                        new DuckSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                }\n                sIsTaskExecuting = false;\n            }\n        });\n    }\n\n}\n\n```\n\n### Response:\n```java\n```java\npackage acr.browser.lightning.search;\n\nimport android.app.Application;\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.anthonycr.bonsai.Action;\nimport com.anthonycr.bonsai.Observable;\nimport com.anthonycr.bonsai.Subscriber;\n\nimport java.util.List;\n\nimport acr.browser.lightning.app.BrowserApp;\nimport acr.browser.lightning.database.HistoryItem;\n\nclass SuggestionsManager {\n\n    public enum Source {\n        GOOGLE,\n        DUCK\n    }\n\n    private static volatile boolean sIsTaskExecuting;\n\n    static boolean isRequestInProgress() {\n        return sIsTaskExecuting;\n    }\n\n    static Observable<List<HistoryItem>> getObservable(@NonNull final String query, @NonNull final Context context, @NonNull final Source source) {\n        final Application application = BrowserApp.get(context);\n        return Observable.create(new Action<List<HistoryItem>>() {\n            @Override\n            public void onSubscribe(@NonNull final Subscriber<List<HistoryItem>> subscriber) {\n                sIsTaskExecuting = true;\n                switch (source) {\n                    case GOOGLE:\n                        GoogleSuggestionsTask googleTask = new GoogleSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        });\n                        googleTask.run();\n                        break;\n                    case DUCK:\n                        DuckSuggestionsTask duckTask = new DuckSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        });\n                        duckTask.run();\n                        break;\n                }\n                sIsTaskExecuting = false;\n            }\n        });\n    }\n\n}\n```"]}
{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/2a899865e653011fca5c814241fc594b224da850","commit_message":"'\\\\\"Catch resource leak on potential exceptions\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.db;\n\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Context context;\n    private SQLiteDatabase db;\n\n    public Database(Context context) {\n        this.context = context;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) throws IOException {\n        InputStream input = context.getAssets().open(dbName);\n        OutputStream output = new FileOutputStream(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = input.read(buffer)) > 0) {\n            output.write(buffer, 0, length);\n        }\n\n        output.close();\n        input.close();\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     *\/\n    public void openDatabase(String dbName) throws IOException, SQLiteException {\n        if (!checkDatabase(dbName)) {\n            copyDatabase(dbName);\n        }\n\n        db = SQLiteDatabase.openDatabase(context.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param query The query itself\n     * @param args  Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String query, String[] args) {\n        return db.rawQuery(query, args);\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        db.close();\n    }\n\n}\n","target_code":"package com.aaronjwood.portauthority.db;\n\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Context context;\n    private SQLiteDatabase db;\n\n    public Database(Context context) {\n        this.context = context;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) throws IOException {\n        InputStream input = context.getAssets().open(dbName);\n        OutputStream output = new FileOutputStream(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        byte[] buffer = new byte[1024];\n        int length;\n        try {\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n        } finally {\n            output.close();\n            input.close();\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     *\/\n    public void openDatabase(String dbName) throws IOException, SQLiteException {\n        if (!checkDatabase(dbName)) {\n            copyDatabase(dbName);\n        }\n\n        db = SQLiteDatabase.openDatabase(context.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param query The query itself\n     * @param args  Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String query, String[] args) {\n        return db.rawQuery(query, args);\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        db.close();\n    }\n\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\npublic class WanIpAsyncTask extends AsyncTask<Void, Void, String> {\n\n    \/\/ IP service is 100% open source https:\/\/github.com\/aaronjwood\/public-ip-api\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/public-ip-api.appspot.com\/\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public WanIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        String error = \"Couldn't get your external IP\";\n        OkHttpClient httpClient = new OkHttpClient();\n        Request request = new Request.Builder().url(EXTERNAL_IP_SERVICE).build();\n\n        try {\n            Response response = httpClient.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (!response.isSuccessful()) {\n                body.close();\n                return error;\n            }\n\n            return response.body().string().trim(); \/\/ string() closes the resource automatically.\n        } catch (IOException e) {\n            return error;\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class WanIpAsyncTask extends AsyncTask<Void, Void, String> {\n\n    \/\/ IP service is 100% open source https:\/\/github.com\/aaronjwood\/public-ip-api\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/public-ip-api.appspot.com\/\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public WanIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        String error = \"Couldn't get your external IP\";\n        OkHttpClient httpClient = new OkHttpClient();\n        Request request = new Request.Builder().url(EXTERNAL_IP_SERVICE).build();\n\n        try {\n            Response response = httpClient.newCall(request).execute();\n            if (!response.isSuccessful()) {\n                return error;\n            }\n\n            return response.body().string().trim();\n        } catch (IOException e) {\n            return error;\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\n\npublic class WanIpAsyncTask extends AsyncTask<Void, Void, String> {\n\n    \/\/ IP service is 100% open source https:\/\/github.com\/aaronjwood\/public-ip-api\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/public-ip-api.appspot.com\/\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public WanIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        String error = \"Couldn't get your external IP\";\n        OkHttpClient httpClient = new OkHttpClient();\n        Request request = new Request.Builder().url(EXTERNAL_IP_SERVICE).build();\n\n        try {\n            Response response = httpClient.newCall(request).execute();\n            if (!response.isSuccessful()) {\n                return error;\n            }\n\n            return response.body().string().trim();\n        } catch (IOException e) {\n            return error;\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\n\npublic class WanIpAsyncTask extends AsyncTask<Void, Void, String> {\n\n    \/\/ IP service is 100% open source https:\/\/github.com\/aaronjwood\/public-ip-api\n    private static final String EXTERNAL_IP_SERVICE = \"https:\/\/public-ip-api.appspot.com\/\";\n    private final WeakReference<MainAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when the external IP has been fetched\n     *\/\n    public WanIpAsyncTask(MainAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Fetch the external IP address\n     *\n     * @param params\n     * @return External IP address\n     *\/\n    @Override\n    protected String doInBackground(Void... params) {\n        String error = \"Couldn't get your external IP\";\n        OkHttpClient httpClient = new OkHttpClient();\n        Request request = new Request.Builder().url(EXTERNAL_IP_SERVICE).build();\n\n        try {\n            Response response = httpClient.newCall(request).execute();\n            ResponseBody body = response.body();\n            if (!response.isSuccessful()) {\n                body.close();\n                return error;\n            }\n\n            return response.body().string().trim(); \/\/ string() closes the resource automatically.\n        } catch (IOException e) {\n            return error;\n        }\n    }\n\n    \/**\n     * Calls the delegate when the external IP has been fetched\n     *\n     * @param result External IP address\n     *\/\n    @Override\n    protected void onPostExecute(String result) {\n        MainAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            activity.processFinish(result);\n        }\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nFix potential memory leaks in the code. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] try...finally\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.db;\n\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Context context;\n    private SQLiteDatabase db;\n\n    public Database(Context context) {\n        this.context = context;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) throws IOException {\n        InputStream input = context.getAssets().open(dbName);\n        OutputStream output = new FileOutputStream(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        byte[] buffer = new byte[1024];\n        int length;\n        try {\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n        } finally {\n            output.close();\n            input.close();\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     *\/\n    public void openDatabase(String dbName) throws IOException, SQLiteException {\n        if (!checkDatabase(dbName)) {\n            copyDatabase(dbName);\n        }\n\n        db = SQLiteDatabase.openDatabase(context.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param query The query itself\n     * @param args  Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String query, String[] args) {\n        return db.rawQuery(query, args);\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        db.close();\n    }\n\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.db;\n\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Context context;\n    private SQLiteDatabase db;\n\n    public Database(Context context) {\n        this.context = context;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) throws IOException {\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            input = context.getAssets().open(dbName);\n            output = new FileOutputStream(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n        } finally {\n            if (output != null) {\n                output.close();\n            }\n            if (input != null) {\n                input.close();\n            }\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     *\/\n    public void openDatabase(String dbName) throws IOException, SQLiteException {\n        if (!checkDatabase(dbName)) {\n            copyDatabase(dbName);\n        }\n\n        db = SQLiteDatabase.openDatabase(context.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param query The query itself\n     * @param args  Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String query, String[] args) {\n        return db.rawQuery(query, args);\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        if (db != null && db.isOpen()) {\n            db.close();\n        }\n    }\n}\n```"]}
{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/85a757ee817dc5f565d578232beabb228cc10d00","commit_message":"'\\\\\"Fix resource leak where we wouldn\\'t close streams if an exception happened\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.db;\n\nimport android.app.Activity;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Activity activity;\n    private SQLiteDatabase db;\n\n    public Database(Activity activity) {\n        this.activity = activity;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) {\n        try {\n            InputStream input = this.activity.getAssets().open(dbName);\n            OutputStream output = new FileOutputStream(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n            output.close();\n            input.close();\n        } catch (IOException ignored) {\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     * @return Database connection\n     *\/\n    private void openDatabase(String dbName) {\n        if (!this.checkDatabase(dbName)) {\n            this.copyDatabase(dbName);\n        }\n        try {\n            this.db = SQLiteDatabase.openDatabase(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n        } catch (SQLiteException e) {\n            this.db = null;\n        }\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param dbName The database to query\n     * @param query  The query itself\n     * @param args   Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String dbName, String query, String[] args) {\n        this.openDatabase(dbName);\n        if (this.db != null) {\n            return db.rawQuery(query, args);\n        } else {\n            return null;\n        }\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        this.db.close();\n    }\n\n}\n","target_code":"package com.aaronjwood.portauthority.db;\n\nimport android.app.Activity;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Activity activity;\n    private SQLiteDatabase db;\n\n    public Database(Activity activity) {\n        this.activity = activity;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) {\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            input = this.activity.getAssets().open(dbName);\n            output = new FileOutputStream(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n\n        } catch (IOException ignored) {\n        } finally {\n            try {\n                if (output != null && input != null) {\n                    output.close();\n                    input.close();\n                }\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     * @return Database connection\n     *\/\n    private void openDatabase(String dbName) {\n        if (!this.checkDatabase(dbName)) {\n            this.copyDatabase(dbName);\n        }\n        try {\n            this.db = SQLiteDatabase.openDatabase(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n        } catch (SQLiteException e) {\n            this.db = null;\n        }\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param dbName The database to query\n     * @param query  The query itself\n     * @param args   Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String dbName, String query, String[] args) {\n        this.openDatabase(dbName);\n        if (this.db != null) {\n            return db.rawQuery(query, args);\n        } else {\n            return null;\n        }\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        this.db.close();\n    }\n\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage acr.browser.lightning.search;\n\nimport android.app.Application;\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.anthonycr.bonsai.Action;\nimport com.anthonycr.bonsai.Observable;\nimport com.anthonycr.bonsai.Subscriber;\n\nimport java.util.List;\n\nimport acr.browser.lightning.app.BrowserApp;\nimport acr.browser.lightning.database.HistoryItem;\n\nclass SuggestionsManager {\n\n    public enum Source {\n        GOOGLE,\n        DUCK\n    }\n\n    private static volatile boolean sIsTaskExecuting;\n\n    static boolean isRequestInProgress() {\n        return sIsTaskExecuting;\n    }\n\n    static Observable<List<HistoryItem>> getObservable(@NonNull final String query, @NonNull final Context context, @NonNull final Source source) {\n        final Application application = BrowserApp.get(context);\n        return Observable.create(new Action<List<HistoryItem>>() {\n            @Override\n            public void onSubscribe(@NonNull final Subscriber<List<HistoryItem>> subscriber) {\n                sIsTaskExecuting = true;\n                switch (source) {\n                    case GOOGLE:\n                        new GoogleSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                        break;\n                    case DUCK:\n                        new DuckSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                }\n                sIsTaskExecuting = false;\n            }\n        });\n    }\n\n}\n\n\nCode-B:\npackage acr.browser.lightning.search;\n\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.anthonycr.bonsai.Action;\nimport com.anthonycr.bonsai.Observable;\nimport com.anthonycr.bonsai.Subscriber;\n\nimport java.util.List;\n\nimport acr.browser.lightning.app.BrowserApp;\nimport acr.browser.lightning.database.HistoryItem;\n\nclass SuggestionsManager {\n\n    public enum Source {\n        GOOGLE,\n        DUCK\n    }\n\n    private static volatile boolean sIsTaskExecuting;\n\n    static boolean isRequestInProgress() {\n        return sIsTaskExecuting;\n    }\n\n    static Observable<List<HistoryItem>> getObservable(@NonNull final String query, @NonNull final Context context, @NonNull final Source source) {\n        return Observable.create(new Action<List<HistoryItem>>() {\n            @Override\n            public void onSubscribe(@NonNull final Subscriber<List<HistoryItem>> subscriber) {\n                sIsTaskExecuting = true;\n                switch (source) {\n                    case GOOGLE:\n                        new GoogleSuggestionsTask(query, BrowserApp.get(context), new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                        break;\n                    case DUCK:\n                        new DuckSuggestionsTask(query, BrowserApp.get(context), new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                }\n                sIsTaskExecuting = false;\n            }\n        });\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage acr.browser.lightning.search;\n\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.anthonycr.bonsai.Action;\nimport com.anthonycr.bonsai.Observable;\nimport com.anthonycr.bonsai.Subscriber;\n\nimport java.util.List;\n\nimport acr.browser.lightning.app.BrowserApp;\nimport acr.browser.lightning.database.HistoryItem;\n\nclass SuggestionsManager {\n\n    public enum Source {\n        GOOGLE,\n        DUCK\n    }\n\n    private static volatile boolean sIsTaskExecuting;\n\n    static boolean isRequestInProgress() {\n        return sIsTaskExecuting;\n    }\n\n    static Observable<List<HistoryItem>> getObservable(@NonNull final String query, @NonNull final Context context, @NonNull final Source source) {\n        return Observable.create(new Action<List<HistoryItem>>() {\n            @Override\n            public void onSubscribe(@NonNull final Subscriber<List<HistoryItem>> subscriber) {\n                sIsTaskExecuting = true;\n                switch (source) {\n                    case GOOGLE:\n                        new GoogleSuggestionsTask(query, BrowserApp.get(context), new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                        break;\n                    case DUCK:\n                        new DuckSuggestionsTask(query, BrowserApp.get(context), new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                }\n                sIsTaskExecuting = false;\n            }\n        });\n    }\n\n}\n\n\nCode-B:\npackage acr.browser.lightning.search;\n\nimport android.app.Application;\nimport android.content.Context;\nimport android.support.annotation.NonNull;\n\nimport com.anthonycr.bonsai.Action;\nimport com.anthonycr.bonsai.Observable;\nimport com.anthonycr.bonsai.Subscriber;\n\nimport java.util.List;\n\nimport acr.browser.lightning.app.BrowserApp;\nimport acr.browser.lightning.database.HistoryItem;\n\nclass SuggestionsManager {\n\n    public enum Source {\n        GOOGLE,\n        DUCK\n    }\n\n    private static volatile boolean sIsTaskExecuting;\n\n    static boolean isRequestInProgress() {\n        return sIsTaskExecuting;\n    }\n\n    static Observable<List<HistoryItem>> getObservable(@NonNull final String query, @NonNull final Context context, @NonNull final Source source) {\n        final Application application = BrowserApp.get(context);\n        return Observable.create(new Action<List<HistoryItem>>() {\n            @Override\n            public void onSubscribe(@NonNull final Subscriber<List<HistoryItem>> subscriber) {\n                sIsTaskExecuting = true;\n                switch (source) {\n                    case GOOGLE:\n                        new GoogleSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                        break;\n                    case DUCK:\n                        new DuckSuggestionsTask(query, application, new SuggestionsResult() {\n                            @Override\n                            public void resultReceived(@NonNull List<HistoryItem> searchResults) {\n                                subscriber.onNext(searchResults);\n                                subscriber.onComplete();\n                            }\n                        }).run();\n                }\n                sIsTaskExecuting = false;\n            }\n        });\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nFix potential memory leaks in the code. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] try...finally\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.db;\n\nimport android.app.Activity;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Activity activity;\n    private SQLiteDatabase db;\n\n    public Database(Activity activity) {\n        this.activity = activity;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) {\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            input = this.activity.getAssets().open(dbName);\n            output = new FileOutputStream(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n\n        } catch (IOException ignored) {\n        } finally {\n            try {\n                if (output != null && input != null) {\n                    output.close();\n                    input.close();\n                }\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     * @return Database connection\n     *\/\n    private void openDatabase(String dbName) {\n        if (!this.checkDatabase(dbName)) {\n            this.copyDatabase(dbName);\n        }\n        try {\n            this.db = SQLiteDatabase.openDatabase(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n        } catch (SQLiteException e) {\n            this.db = null;\n        }\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param dbName The database to query\n     * @param query  The query itself\n     * @param args   Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String dbName, String query, String[] args) {\n        this.openDatabase(dbName);\n        if (this.db != null) {\n            return db.rawQuery(query, args);\n        } else {\n            return null;\n        }\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        this.db.close();\n    }\n\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.db;\n\nimport android.app.Activity;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Activity activity;\n    private SQLiteDatabase db;\n\n    public Database(Activity activity) {\n        this.activity = activity;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) {\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            input = this.activity.getAssets().open(dbName);\n            output = new FileOutputStream(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n        } catch (IOException ignored) {\n        } finally {\n            try {\n                if (output != null) {\n                    output.close();\n                }\n            } catch (IOException ignored) {\n            }\n            try {\n                if (input != null) {\n                    input.close();\n                }\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     * @return Database connection\n     *\/\n    private void openDatabase(String dbName) {\n        if (!this.checkDatabase(dbName)) {\n            this.copyDatabase(dbName);\n        }\n        try {\n            this.db = SQLiteDatabase.openDatabase(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n        } catch (SQLiteException e) {\n            this.db = null;\n        }\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param dbName The database to query\n     * @param query  The query itself\n     * @param args   Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String dbName, String query, String[] args) {\n        this.openDatabase(dbName);\n        if (this.db != null) {\n            return db.rawQuery(query, args);\n        } else {\n            return null;\n        }\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        if (this.db != null) {\n            this.db.close();\n        }\n    }\n}\n```"]}
{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/c91cc795f9e7ec17d9afab10cdc9a373c6c254ea","commit_message":"'\\\\\"Fix resource leak\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            this.delegate.processFinish(1);\n\n            HashMap<Integer, String> portData = new HashMap<>();\n            BufferedReader in;\n            String data = null;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443 || i == 8080) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}\n","target_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            this.delegate.processFinish(1);\n\n            HashMap<Integer, String> portData = new HashMap<>();\n            BufferedReader in;\n            String data = null;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443 || i == 8080) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n    }\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.db;\n\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Context context;\n    private SQLiteDatabase db;\n\n    public Database(Context context) {\n        this.context = context;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) throws IOException {\n        InputStream input = context.getAssets().open(dbName);\n        OutputStream output = new FileOutputStream(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        byte[] buffer = new byte[1024];\n        int length;\n        try {\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n        } finally {\n            output.close();\n            input.close();\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     *\/\n    public void openDatabase(String dbName) throws IOException, SQLiteException {\n        if (!checkDatabase(dbName)) {\n            copyDatabase(dbName);\n        }\n\n        db = SQLiteDatabase.openDatabase(context.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param query The query itself\n     * @param args  Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String query, String[] args) {\n        return db.rawQuery(query, args);\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        db.close();\n    }\n\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.db;\n\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Context context;\n    private SQLiteDatabase db;\n\n    public Database(Context context) {\n        this.context = context;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) throws IOException {\n        InputStream input = context.getAssets().open(dbName);\n        OutputStream output = new FileOutputStream(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = input.read(buffer)) > 0) {\n            output.write(buffer, 0, length);\n        }\n\n        output.close();\n        input.close();\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     *\/\n    public void openDatabase(String dbName) throws IOException, SQLiteException {\n        if (!checkDatabase(dbName)) {\n            copyDatabase(dbName);\n        }\n\n        db = SQLiteDatabase.openDatabase(context.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param query The query itself\n     * @param args  Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String query, String[] args) {\n        return db.rawQuery(query, args);\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        db.close();\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.db;\n\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Context context;\n    private SQLiteDatabase db;\n\n    public Database(Context context) {\n        this.context = context;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) throws IOException {\n        InputStream input = context.getAssets().open(dbName);\n        OutputStream output = new FileOutputStream(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = input.read(buffer)) > 0) {\n            output.write(buffer, 0, length);\n        }\n\n        output.close();\n        input.close();\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     *\/\n    public void openDatabase(String dbName) throws IOException, SQLiteException {\n        if (!checkDatabase(dbName)) {\n            copyDatabase(dbName);\n        }\n\n        db = SQLiteDatabase.openDatabase(context.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param query The query itself\n     * @param args  Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String query, String[] args) {\n        return db.rawQuery(query, args);\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        db.close();\n    }\n\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.db;\n\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Context context;\n    private SQLiteDatabase db;\n\n    public Database(Context context) {\n        this.context = context;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) throws IOException {\n        InputStream input = context.getAssets().open(dbName);\n        OutputStream output = new FileOutputStream(context.getApplicationInfo().dataDir + \"\/\" + dbName);\n\n        byte[] buffer = new byte[1024];\n        int length;\n        try {\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n        } finally {\n            output.close();\n            input.close();\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     *\/\n    public void openDatabase(String dbName) throws IOException, SQLiteException {\n        if (!checkDatabase(dbName)) {\n            copyDatabase(dbName);\n        }\n\n        db = SQLiteDatabase.openDatabase(context.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param query The query itself\n     * @param args  Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String query, String[] args) {\n        return db.rawQuery(query, args);\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        db.close();\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nFix potential memory leaks in the code. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] try...finally\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            this.delegate.processFinish(1);\n\n            HashMap<Integer, String> portData = new HashMap<>();\n            BufferedReader in;\n            String data = null;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443 || i == 8080) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n    }\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            this.delegate.processFinish(1);\n\n            HashMap<Integer, String> portData = new HashMap<>();\n            BufferedReader in = null;\n            PrintWriter out = null;\n            String data = null;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                } else if (i == 80 || i == 443 || i == 8080) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    if (in != null) {\n                        in.close();\n                    }\n                    if (out != null) {\n                        out.close();\n                    }\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n    }\n}\n```"]}
{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/3b4e6a736603a1979fdbfa8562f6ba1dd47bb9e2","commit_message":"'\\\\\"Reduce memory usage by only allocating the BufferedReader when necessary. Reduce calls that send data through the socket to improve efficiency\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(1);\n                Socket socket = new Socket();\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n\n                HashMap<Integer, String> portData = new HashMap<>();\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String data = null;\n\n                if (i == 22) {\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443) {\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\");\n                    out.println(\"Host: \" + this.ip);\n                    out.println(\"\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}\n","target_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(1);\n                Socket socket = new Socket();\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n\n                HashMap<Integer, String> portData = new HashMap<>();\n                BufferedReader in;\n                String data = null;\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.db;\n\nimport android.app.Activity;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Activity activity;\n    private SQLiteDatabase db;\n\n    public Database(Activity activity) {\n        this.activity = activity;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) {\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            input = this.activity.getAssets().open(dbName);\n            output = new FileOutputStream(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n\n        } catch (IOException ignored) {\n        } finally {\n            try {\n                if (output != null && input != null) {\n                    output.close();\n                    input.close();\n                }\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     * @return Database connection\n     *\/\n    private void openDatabase(String dbName) {\n        if (!this.checkDatabase(dbName)) {\n            this.copyDatabase(dbName);\n        }\n        try {\n            this.db = SQLiteDatabase.openDatabase(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n        } catch (SQLiteException e) {\n            this.db = null;\n        }\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param dbName The database to query\n     * @param query  The query itself\n     * @param args   Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String dbName, String query, String[] args) {\n        this.openDatabase(dbName);\n        if (this.db != null) {\n            return db.rawQuery(query, args);\n        } else {\n            return null;\n        }\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        this.db.close();\n    }\n\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.db;\n\nimport android.app.Activity;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Activity activity;\n    private SQLiteDatabase db;\n\n    public Database(Activity activity) {\n        this.activity = activity;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) {\n        try {\n            InputStream input = this.activity.getAssets().open(dbName);\n            OutputStream output = new FileOutputStream(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n            output.close();\n            input.close();\n        } catch (IOException ignored) {\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     * @return Database connection\n     *\/\n    private void openDatabase(String dbName) {\n        if (!this.checkDatabase(dbName)) {\n            this.copyDatabase(dbName);\n        }\n        try {\n            this.db = SQLiteDatabase.openDatabase(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n        } catch (SQLiteException e) {\n            this.db = null;\n        }\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param dbName The database to query\n     * @param query  The query itself\n     * @param args   Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String dbName, String query, String[] args) {\n        this.openDatabase(dbName);\n        if (this.db != null) {\n            return db.rawQuery(query, args);\n        } else {\n            return null;\n        }\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        this.db.close();\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.db;\n\nimport android.app.Activity;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Activity activity;\n    private SQLiteDatabase db;\n\n    public Database(Activity activity) {\n        this.activity = activity;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) {\n        try {\n            InputStream input = this.activity.getAssets().open(dbName);\n            OutputStream output = new FileOutputStream(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n            output.close();\n            input.close();\n        } catch (IOException ignored) {\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     * @return Database connection\n     *\/\n    private void openDatabase(String dbName) {\n        if (!this.checkDatabase(dbName)) {\n            this.copyDatabase(dbName);\n        }\n        try {\n            this.db = SQLiteDatabase.openDatabase(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n        } catch (SQLiteException e) {\n            this.db = null;\n        }\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param dbName The database to query\n     * @param query  The query itself\n     * @param args   Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String dbName, String query, String[] args) {\n        this.openDatabase(dbName);\n        if (this.db != null) {\n            return db.rawQuery(query, args);\n        } else {\n            return null;\n        }\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        this.db.close();\n    }\n\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.db;\n\nimport android.app.Activity;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteException;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class Database {\n    private Activity activity;\n    private SQLiteDatabase db;\n\n    public Database(Activity activity) {\n        this.activity = activity;\n    }\n\n    \/**\n     * Checks if the database exists at the application's data directory\n     *\n     * @param dbName Name of the database to check the existence of\n     * @return True if the database exists, false if not\n     *\/\n    private boolean checkDatabase(String dbName) {\n        File dbFile = new File(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n        return dbFile.exists();\n    }\n\n    \/**\n     * Copies the database from assets to the application's data directory\n     *\n     * @param dbName Name of the database to be copied\n     *\/\n    private void copyDatabase(String dbName) {\n        InputStream input = null;\n        OutputStream output = null;\n        try {\n            input = this.activity.getAssets().open(dbName);\n            output = new FileOutputStream(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName);\n            byte[] buffer = new byte[1024];\n            int length;\n            while ((length = input.read(buffer)) > 0) {\n                output.write(buffer, 0, length);\n            }\n\n        } catch (IOException ignored) {\n        } finally {\n            try {\n                if (output != null && input != null) {\n                    output.close();\n                    input.close();\n                }\n            } catch (IOException ignored) {\n            }\n        }\n    }\n\n    \/**\n     * Opens a connection to a SQLite database\n     *\n     * @param dbName The database to open a connection to\n     * @return Database connection\n     *\/\n    private void openDatabase(String dbName) {\n        if (!this.checkDatabase(dbName)) {\n            this.copyDatabase(dbName);\n        }\n        try {\n            this.db = SQLiteDatabase.openDatabase(this.activity.getApplicationInfo().dataDir + \"\/\" + dbName, null, SQLiteDatabase.OPEN_READONLY);\n        } catch (SQLiteException e) {\n            this.db = null;\n        }\n    }\n\n    \/**\n     * Performs a query against the database\n     *\n     * @param dbName The database to query\n     * @param query  The query itself\n     * @param args   Arguments for any bound parameters\n     * @return Cursor for iterating over results\n     *\/\n    public Cursor queryDatabase(String dbName, String query, String[] args) {\n        this.openDatabase(dbName);\n        if (this.db != null) {\n            return db.rawQuery(query, args);\n        } else {\n            return null;\n        }\n    }\n\n    \/**\n     * Closes the database handle\n     *\/\n    public void close() {\n        this.db.close();\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the code to reduce memory usage and improve efficiency. Write the entire code and no other text in the response.\n\n### Concepts:\n[hint] socket calls are expensive\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(1);\n                Socket socket = new Socket();\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n\n                HashMap<Integer, String> portData = new HashMap<>();\n                BufferedReader in;\n                String data = null;\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        HashMap<Integer, String> portData = new HashMap<>();\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            try (Socket socket = new Socket()) {\n                this.delegate.processFinish(1);\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n\n                String data = null;\n\n                if (i == 22) {\n                    try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {\n                        data = in.readLine();\n                    }\n                } else if (i == 80 || i == 443) {\n                    try (BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                         PrintWriter out = new PrintWriter(socket.getOutputStream(), true)) {\n                        out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                        char[] buffer = new char[1024];\n                        in.read(buffer, 0, 1024);\n                        data = new String(buffer).toLowerCase();\n                        if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                            data = \"Apache\";\n                        } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                            data = \"IIS\";\n                        } else if (data.contains(\"nginx\")) {\n                            data = \"Nginx\";\n                        } else {\n                            data = null;\n                        }\n                    }\n                }\n\n                portData.put(i, data);\n            } catch (IOException ignored) {\n            }\n        }\n        this.delegate.processFinish(portData);\n    }\n}\n```"]}
{"non_functional_requirement":"memory","commit":"https:\/\/github.com\/btmura\/rbb\/commit\/649624da807bfd6238428775d982e8316a59befd","commit_message":"'\\\\\"Fix DbHelper context memory leak\\\\n\\\\\"'","source_code":"\/*\n * Copyright (C) 2012 Brian Muramatsu\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage com.btmura.android.reddit.database;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\n\npublic class DbHelper extends SQLiteOpenHelper {\n\n    static final String DATABASE_REDDIT = \"reddit\";\n    static final String DATABASE_TEST = \"test\";\n    static final int LATEST_VERSION = 2;\n\n    \/** Singleton instances accessible via {@link #getInstance(Context)}. *\/\n    private static DbHelper INSTANCE;\n\n    \/**\n     * Return singleton instance of {@link DbHelper} that all users should use\n     * to avoid database locked errors. Make sure to do database writes in\n     * serial though.\n     *\/\n    public static DbHelper getInstance(Context context) {\n        synchronized (DbHelper.class) {\n            if (INSTANCE == null) {\n                INSTANCE = new DbHelper(context, DATABASE_REDDIT, LATEST_VERSION);\n            }\n            return INSTANCE;\n        }\n    }\n\n    \/** Version kept to control what tables are created mostly for testing. *\/\n    private final int version;\n\n    \/** Test constructor. Use {@link #getInstance(Context, String, int)}. *\/\n    DbHelper(Context context, String name, int version) {\n        super(context, name, null, version);\n        this.version = version;\n    }\n\n    @Override\n    public void onOpen(SQLiteDatabase db) {\n        if (!db.isReadOnly()) {\n            Sessions.createTempTable(db);\n            Things.createTempTable(db);\n            Messages.createTempTable(db);\n            SubredditResults.createTempTable(db);\n        }\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        if (version > 1) {\n            Subreddits.createSubredditsV2(db);\n            createNewTablesV2(db);\n        } else {\n            Subreddits.createSubredditsV1(db);\n        }\n        Subreddits.insertDefaultSubreddits(db);\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        if (oldVersion == 1 && newVersion == 2) {\n            Subreddits.upgradeSubredditsV2(db);\n            createNewTablesV2(db);\n        }\n    }\n\n    private static void createNewTablesV2(SQLiteDatabase db) {\n        Accounts.createTable(db);\n        CommentActions.createTable(db);\n        MessageActions.createTable(db);\n        ReadActions.createTable(db);\n        SaveActions.createTable(db);\n        VoteActions.createTable(db);\n    }\n}","target_code":"\/*\n * Copyright (C) 2012 Brian Muramatsu\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage com.btmura.android.reddit.database;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\n\npublic class DbHelper extends SQLiteOpenHelper {\n\n    static final String DATABASE_REDDIT = \"reddit\";\n    static final String DATABASE_TEST = \"test\";\n    static final int LATEST_VERSION = 2;\n\n    \/** Singleton instances accessible via {@link #getInstance(Context)}. *\/\n    private static DbHelper INSTANCE;\n\n    \/**\n     * Return singleton instance of {@link DbHelper} that all users should use\n     * to avoid database locked errors. Make sure to do database writes in\n     * serial though.\n     *\/\n    public static DbHelper getInstance(Context context) {\n        synchronized (DbHelper.class) {\n            if (INSTANCE == null) {\n                INSTANCE = new DbHelper(context.getApplicationContext(),\n                        DATABASE_REDDIT, LATEST_VERSION);\n            }\n            return INSTANCE;\n        }\n    }\n\n    \/** Version kept to control what tables are created mostly for testing. *\/\n    private final int version;\n\n    \/** Test constructor. Use {@link #getInstance(Context, String, int)}. *\/\n    DbHelper(Context context, String name, int version) {\n        super(context, name, null, version);\n        this.version = version;\n    }\n\n    @Override\n    public void onOpen(SQLiteDatabase db) {\n        if (!db.isReadOnly()) {\n            Sessions.createTempTable(db);\n            Things.createTempTable(db);\n            Messages.createTempTable(db);\n            SubredditResults.createTempTable(db);\n        }\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        if (version > 1) {\n            Subreddits.createSubredditsV2(db);\n            createNewTablesV2(db);\n        } else {\n            Subreddits.createSubredditsV1(db);\n        }\n        Subreddits.insertDefaultSubreddits(db);\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        if (oldVersion == 1 && newVersion == 2) {\n            Subreddits.upgradeSubredditsV2(db);\n            createNewTablesV2(db);\n        }\n    }\n\n    private static void createNewTablesV2(SQLiteDatabase db) {\n        Accounts.createTable(db);\n        CommentActions.createTable(db);\n        MessageActions.createTable(db);\n        ReadActions.createTable(db);\n        SaveActions.createTable(db);\n        VoteActions.createTable(db);\n    }\n}","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            this.delegate.processFinish(1);\n\n            HashMap<Integer, String> portData = new HashMap<>();\n            BufferedReader in;\n            String data = null;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443 || i == 8080) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            this.delegate.processFinish(1);\n\n            HashMap<Integer, String> portData = new HashMap<>();\n            BufferedReader in;\n            String data = null;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443 || i == 8080) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower memory usage.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            this.delegate.processFinish(1);\n\n            HashMap<Integer, String> portData = new HashMap<>();\n            BufferedReader in;\n            String data = null;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443 || i == 8080) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.startPort; i <= this.stopPort; i++) {\n            this.delegate.processFinish(1);\n\n            HashMap<Integer, String> portData = new HashMap<>();\n            BufferedReader in;\n            String data = null;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n\n                if (i == 22) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    data = in.readLine();\n                    in.close();\n                } else if (i == 80 || i == 443 || i == 8080) {\n                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\\r\\nHost: \" + this.ip + \"\\r\\n\");\n\n                    char[] buffer = new char[1024];\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if (data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    } else if (data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    } else if (data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    } else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                this.delegate.processFinish(portData);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower memory usage utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":20.4351668872,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nFix potential memory leaks in the code. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] android.content.Context.getApplicationContext()\n[in] getInstance function\n\n### Given program:\n```java\n\/*\n * Copyright (C) 2012 Brian Muramatsu\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage com.btmura.android.reddit.database;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\n\npublic class DbHelper extends SQLiteOpenHelper {\n\n    static final String DATABASE_REDDIT = \"reddit\";\n    static final String DATABASE_TEST = \"test\";\n    static final int LATEST_VERSION = 2;\n\n    \/** Singleton instances accessible via {@link #getInstance(Context)}. *\/\n    private static DbHelper INSTANCE;\n\n    \/**\n     * Return singleton instance of {@link DbHelper} that all users should use\n     * to avoid database locked errors. Make sure to do database writes in\n     * serial though.\n     *\/\n    public static DbHelper getInstance(Context context) {\n        synchronized (DbHelper.class) {\n            if (INSTANCE == null) {\n                INSTANCE = new DbHelper(context.getApplicationContext(),\n                        DATABASE_REDDIT, LATEST_VERSION);\n            }\n            return INSTANCE;\n        }\n    }\n\n    \/** Version kept to control what tables are created mostly for testing. *\/\n    private final int version;\n\n    \/** Test constructor. Use {@link #getInstance(Context, String, int)}. *\/\n    DbHelper(Context context, String name, int version) {\n        super(context, name, null, version);\n        this.version = version;\n    }\n\n    @Override\n    public void onOpen(SQLiteDatabase db) {\n        if (!db.isReadOnly()) {\n            Sessions.createTempTable(db);\n            Things.createTempTable(db);\n            Messages.createTempTable(db);\n            SubredditResults.createTempTable(db);\n        }\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        if (version > 1) {\n            Subreddits.createSubredditsV2(db);\n            createNewTablesV2(db);\n        } else {\n            Subreddits.createSubredditsV1(db);\n        }\n        Subreddits.insertDefaultSubreddits(db);\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        if (oldVersion == 1 && newVersion == 2) {\n            Subreddits.upgradeSubredditsV2(db);\n            createNewTablesV2(db);\n        }\n    }\n\n    private static void createNewTablesV2(SQLiteDatabase db) {\n        Accounts.createTable(db);\n        CommentActions.createTable(db);\n        MessageActions.createTable(db);\n        ReadActions.createTable(db);\n        SaveActions.createTable(db);\n        VoteActions.createTable(db);\n    }\n}\n```\n\n### Response:\n```java\n```java\n\/*\n * Copyright (C) 2012 Brian Muramatsu\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\npackage com.btmura.android.reddit.database;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\n\npublic class DbHelper extends SQLiteOpenHelper {\n\n    static final String DATABASE_REDDIT = \"reddit\";\n    static final String DATABASE_TEST = \"test\";\n    static final int LATEST_VERSION = 2;\n\n    \/** Singleton instances accessible via {@link #getInstance(Context)}. *\/\n    private static DbHelper INSTANCE;\n\n    \/**\n     * Return singleton instance of {@link DbHelper} that all users should use\n     * to avoid database locked errors. Make sure to do database writes in\n     * serial though.\n     *\/\n    public static DbHelper getInstance(Context context) {\n        synchronized (DbHelper.class) {\n            if (INSTANCE == null) {\n                INSTANCE = new DbHelper(context.getApplicationContext(),\n                        DATABASE_REDDIT, LATEST_VERSION);\n            }\n            return INSTANCE;\n        }\n    }\n\n    \/** Version kept to control what tables are created mostly for testing. *\/\n    private final int version;\n\n    \/** Test constructor. Use {@link #getInstance(Context, String, int)}. *\/\n    DbHelper(Context context, String name, int version) {\n        super(context, name, null, version);\n        this.version = version;\n    }\n\n    @Override\n    public void onOpen(SQLiteDatabase db) {\n        if (!db.isReadOnly()) {\n            Sessions.createTempTable(db);\n            Things.createTempTable(db);\n            Messages.createTempTable(db);\n            SubredditResults.createTempTable(db);\n        }\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        if (version > 1) {\n            Subreddits.createSubredditsV2(db);\n            createNewTablesV2(db);\n        } else {\n            Subreddits.createSubredditsV1(db);\n        }\n        Subreddits.insertDefaultSubreddits(db);\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        if (oldVersion == 1 && newVersion == 2) {\n            Subreddits.upgradeSubredditsV2(db);\n            createNewTablesV2(db);\n        }\n    }\n\n    private static void createNewTablesV2(SQLiteDatabase db) {\n        Accounts.createTable(db);\n        CommentActions.createTable(db);\n        MessageActions.createTable(db);\n        ReadActions.createTable(db);\n        SaveActions.createTable(db);\n        VoteActions.createTable(db);\n    }\n}\n```"]}