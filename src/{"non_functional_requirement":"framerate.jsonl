{"non_functional_requirement":"framerate","commit":"https:\/\/github.com\/onyxbits\/listmyaps\/commit\/5065990868de934c2c9aa5dfce01b69b362eb94e","commit_message":"'\\\\\"BUGFIX: Recycle views to scroll faster\\\\n\\\\\"'","source_code":"package de.onyxbits.listmyapps;\n\nimport java.util.List;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.CheckBox;\nimport android.widget.TextView;\n\npublic class AppAdapter extends ArrayAdapter<SortablePackageInfo> {\n\n\tpublic AppAdapter(Context context, int textViewResourceId,\n\t\t\tList<SortablePackageInfo> spi) {\n\t\tsuper(context, textViewResourceId, spi);\n\t}\n\t\n  @Override\n  public View getView(int position, View convertView, ViewGroup parent) {\n    View ret;\n    SortablePackageInfo spi = getItem(position);\n    \n    LayoutInflater inflater = (LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    ret = inflater.inflate(R.layout.app_item,null);\n    ((TextView)ret.findViewById(R.id.appname)).setText(spi.displayName);\n    ((TextView)ret.findViewById(R.id.apppackage)).setText(spi.packageName);\n    CheckBox sel = ((CheckBox)ret.findViewById(R.id.selected));\n    sel.setOnClickListener(spi);\n    sel.setChecked(spi.selected);\n    return ret;\n\n  }\n\n}\n","target_code":"package de.onyxbits.listmyapps;\n\nimport java.util.List;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.CheckBox;\nimport android.widget.TextView;\n\npublic class AppAdapter extends ArrayAdapter<SortablePackageInfo> {\n\n\tpublic AppAdapter(Context context, int textViewResourceId,\n\t\t\tList<SortablePackageInfo> spi) {\n\t\tsuper(context, textViewResourceId, spi);\n\t}\n\t\n  @Override\n  public View getView(int position, View convertView, ViewGroup parent) {\n    View ret=convertView;\n    if (ret==null) {\n    \tLayoutInflater inflater = (LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    \tret = inflater.inflate(R.layout.app_item,null);\n    }\n    SortablePackageInfo spi = getItem(position);\n    \n    ((TextView)ret.findViewById(R.id.appname)).setText(spi.displayName);\n    ((TextView)ret.findViewById(R.id.apppackage)).setText(spi.packageName);\n    CheckBox sel = ((CheckBox)ret.findViewById(R.id.selected));\n    sel.setChecked(spi.selected);\n    sel.setOnClickListener(spi);\n    \n    return ret;\n\n  }\n\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower frame rate.\n\nCode-A:\n\/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/. *\/\n\npackage org.mozilla.focus;\n\nimport android.app.Application;\nimport android.preference.PreferenceManager;\n\nimport org.mozilla.focus.search.SearchEngineManager;\nimport org.mozilla.focus.telemetry.TelemetryWrapper;\nimport org.mozilla.focus.utils.AdjustHelper;\n\npublic class FocusApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        \/\/ Loading preferences depends on the Search Engine manager, because the default search\n        \/\/ engine pref uses the search engine manager - we therefore need to ensure\n        \/\/ that prefs aren't loaded until search engines are loaded.\n        SearchEngineManager.getInstance().init(this);\n\n        PreferenceManager.setDefaultValues(this, R.xml.settings, false);\n\n        TelemetryWrapper.init(this);\n        AdjustHelper.setupAdjustIfNeeded(this);\n    }\n}\n\n\nCode-B:\n\/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/. *\/\n\npackage org.mozilla.focus;\n\nimport android.app.Application;\nimport android.preference.PreferenceManager;\n\nimport org.mozilla.focus.search.SearchEngineManager;\nimport org.mozilla.focus.telemetry.TelemetryWrapper;\nimport org.mozilla.focus.utils.AdjustHelper;\n\npublic class FocusApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        PreferenceManager.setDefaultValues(this, R.xml.settings, false);\n\n        SearchEngineManager.getInstance().init(this);\n\n        TelemetryWrapper.init(this);\n        AdjustHelper.setupAdjustIfNeeded(this);\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower frame rate utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower frame rate.\n\nCode-A:\n\/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/. *\/\n\npackage org.mozilla.focus;\n\nimport android.app.Application;\nimport android.preference.PreferenceManager;\n\nimport org.mozilla.focus.search.SearchEngineManager;\nimport org.mozilla.focus.telemetry.TelemetryWrapper;\nimport org.mozilla.focus.utils.AdjustHelper;\n\npublic class FocusApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        PreferenceManager.setDefaultValues(this, R.xml.settings, false);\n\n        SearchEngineManager.getInstance().init(this);\n\n        TelemetryWrapper.init(this);\n        AdjustHelper.setupAdjustIfNeeded(this);\n    }\n}\n\n\nCode-B:\n\/* -*- Mode: Java; c-basic-offset: 4; tab-width: 20; indent-tabs-mode: nil; -*-\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http:\/\/mozilla.org\/MPL\/2.0\/. *\/\n\npackage org.mozilla.focus;\n\nimport android.app.Application;\nimport android.preference.PreferenceManager;\n\nimport org.mozilla.focus.search.SearchEngineManager;\nimport org.mozilla.focus.telemetry.TelemetryWrapper;\nimport org.mozilla.focus.utils.AdjustHelper;\n\npublic class FocusApplication extends Application {\n    @Override\n    public void onCreate() {\n        super.onCreate();\n\n        \/\/ Loading preferences depends on the Search Engine manager, because the default search\n        \/\/ engine pref uses the search engine manager - we therefore need to ensure\n        \/\/ that prefs aren't loaded until search engines are loaded.\n        SearchEngineManager.getInstance().init(this);\n\n        PreferenceManager.setDefaultValues(this, R.xml.settings, false);\n\n        TelemetryWrapper.init(this);\n        AdjustHelper.setupAdjustIfNeeded(this);\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower frame rate utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the code to make scrolling faster and improve user experience of the android application. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] recycle convertView object\n\n### Given program:\n```java\npackage de.onyxbits.listmyapps;\n\nimport java.util.List;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.CheckBox;\nimport android.widget.TextView;\n\npublic class AppAdapter extends ArrayAdapter<SortablePackageInfo> {\n\n\tpublic AppAdapter(Context context, int textViewResourceId,\n\t\t\tList<SortablePackageInfo> spi) {\n\t\tsuper(context, textViewResourceId, spi);\n\t}\n\t\n  @Override\n  public View getView(int position, View convertView, ViewGroup parent) {\n    View ret;\n    SortablePackageInfo spi = getItem(position);\n    \n    LayoutInflater inflater = (LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    ret = inflater.inflate(R.layout.app_item,null);\n    ((TextView)ret.findViewById(R.id.appname)).setText(spi.displayName);\n    ((TextView)ret.findViewById(R.id.apppackage)).setText(spi.packageName);\n    CheckBox sel = ((CheckBox)ret.findViewById(R.id.selected));\n    sel.setOnClickListener(spi);\n    sel.setChecked(spi.selected);\n    return ret;\n\n  }\n\n}\n\n```\n\n### Response:\n```java\n```java\npackage de.onyxbits.listmyapps;\n\nimport java.util.List;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.CheckBox;\nimport android.widget.TextView;\n\npublic class AppAdapter extends ArrayAdapter<SortablePackageInfo> {\n\n    private LayoutInflater inflater;\n\n    public AppAdapter(Context context, int textViewResourceId, List<SortablePackageInfo> spi) {\n        super(context, textViewResourceId, spi);\n        inflater = LayoutInflater.from(context);\n    }\n    \n    @Override\n    public View getView(int position, View convertView, ViewGroup parent) {\n        ViewHolder holder;\n        if (convertView == null) {\n            convertView = inflater.inflate(R.layout.app_item, parent, false);\n            holder = new ViewHolder();\n            holder.appName = (TextView) convertView.findViewById(R.id.appname);\n            holder.appPackage = (TextView) convertView.findViewById(R.id.apppackage);\n            holder.selected = (CheckBox) convertView.findViewById(R.id.selected);\n            convertView.setTag(holder);\n        } else {\n            holder = (ViewHolder) convertView.getTag();\n        }\n\n        SortablePackageInfo spi = getItem(position);\n        holder.appName.setText(spi.displayName);\n        holder.appPackage.setText(spi.packageName);\n        holder.selected.setOnClickListener(spi);\n        holder.selected.setChecked(spi.selected);\n        \n        return convertView;\n    }\n\n    static class ViewHolder {\n        TextView appName;\n        TextView appPackage;\n        CheckBox selected;\n    }\n}\n```"]}
{"non_functional_requirement":"executiontime","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/251e9ea3d07dfe09c911041ee841d78acbfa5eba","commit_message":"'\\\\\"Use a socket connection when scanning for hosts instead of isReachable. Set performance options to prefer fast connection. Enable TCP_NODELAY\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\n\npublic class ScanHostsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanHostsRunnable\";\n\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.start; i <= this.stop; i++) {\n            String newIp = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                InetAddress address = InetAddress.getByName(newIp);\n                address.isReachable(100);\n            }\n            catch(IOException ignored) {\n            }\n            finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}","target_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanHostsRunnable\";\n\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.start; i <= this.stop; i++) {\n            String newIp = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(newIp, 7), 100);\n            }\n            catch(IOException ignored) {\n            }\n            finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower frame rate.\n\nCode-A:\npackage de.onyxbits.listmyapps;\n\nimport java.util.List;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.CheckBox;\nimport android.widget.TextView;\n\npublic class AppAdapter extends ArrayAdapter<SortablePackageInfo> {\n\n\tpublic AppAdapter(Context context, int textViewResourceId,\n\t\t\tList<SortablePackageInfo> spi) {\n\t\tsuper(context, textViewResourceId, spi);\n\t}\n\t\n  @Override\n  public View getView(int position, View convertView, ViewGroup parent) {\n    View ret=convertView;\n    if (ret==null) {\n    \tLayoutInflater inflater = (LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    \tret = inflater.inflate(R.layout.app_item,null);\n    }\n    SortablePackageInfo spi = getItem(position);\n    \n    ((TextView)ret.findViewById(R.id.appname)).setText(spi.displayName);\n    ((TextView)ret.findViewById(R.id.apppackage)).setText(spi.packageName);\n    CheckBox sel = ((CheckBox)ret.findViewById(R.id.selected));\n    sel.setChecked(spi.selected);\n    sel.setOnClickListener(spi);\n    \n    return ret;\n\n  }\n\n}\n\n\nCode-B:\npackage de.onyxbits.listmyapps;\n\nimport java.util.List;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.CheckBox;\nimport android.widget.TextView;\n\npublic class AppAdapter extends ArrayAdapter<SortablePackageInfo> {\n\n\tpublic AppAdapter(Context context, int textViewResourceId,\n\t\t\tList<SortablePackageInfo> spi) {\n\t\tsuper(context, textViewResourceId, spi);\n\t}\n\t\n  @Override\n  public View getView(int position, View convertView, ViewGroup parent) {\n    View ret;\n    SortablePackageInfo spi = getItem(position);\n    \n    LayoutInflater inflater = (LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    ret = inflater.inflate(R.layout.app_item,null);\n    ((TextView)ret.findViewById(R.id.appname)).setText(spi.displayName);\n    ((TextView)ret.findViewById(R.id.apppackage)).setText(spi.packageName);\n    CheckBox sel = ((CheckBox)ret.findViewById(R.id.selected));\n    sel.setOnClickListener(spi);\n    sel.setChecked(spi.selected);\n    return ret;\n\n  }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower frame rate utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower frame rate.\n\nCode-A:\npackage de.onyxbits.listmyapps;\n\nimport java.util.List;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.CheckBox;\nimport android.widget.TextView;\n\npublic class AppAdapter extends ArrayAdapter<SortablePackageInfo> {\n\n\tpublic AppAdapter(Context context, int textViewResourceId,\n\t\t\tList<SortablePackageInfo> spi) {\n\t\tsuper(context, textViewResourceId, spi);\n\t}\n\t\n  @Override\n  public View getView(int position, View convertView, ViewGroup parent) {\n    View ret;\n    SortablePackageInfo spi = getItem(position);\n    \n    LayoutInflater inflater = (LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    ret = inflater.inflate(R.layout.app_item,null);\n    ((TextView)ret.findViewById(R.id.appname)).setText(spi.displayName);\n    ((TextView)ret.findViewById(R.id.apppackage)).setText(spi.packageName);\n    CheckBox sel = ((CheckBox)ret.findViewById(R.id.selected));\n    sel.setOnClickListener(spi);\n    sel.setChecked(spi.selected);\n    return ret;\n\n  }\n\n}\n\n\nCode-B:\npackage de.onyxbits.listmyapps;\n\nimport java.util.List;\n\nimport android.content.Context;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.CheckBox;\nimport android.widget.TextView;\n\npublic class AppAdapter extends ArrayAdapter<SortablePackageInfo> {\n\n\tpublic AppAdapter(Context context, int textViewResourceId,\n\t\t\tList<SortablePackageInfo> spi) {\n\t\tsuper(context, textViewResourceId, spi);\n\t}\n\t\n  @Override\n  public View getView(int position, View convertView, ViewGroup parent) {\n    View ret=convertView;\n    if (ret==null) {\n    \tLayoutInflater inflater = (LayoutInflater)getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n    \tret = inflater.inflate(R.layout.app_item,null);\n    }\n    SortablePackageInfo spi = getItem(position);\n    \n    ((TextView)ret.findViewById(R.id.appname)).setText(spi.displayName);\n    ((TextView)ret.findViewById(R.id.apppackage)).setText(spi.packageName);\n    CheckBox sel = ((CheckBox)ret.findViewById(R.id.selected));\n    sel.setChecked(spi.selected);\n    sel.setOnClickListener(spi);\n    \n    return ret;\n\n  }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower frame rate utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the code using a socket connection when scanning for hosts to improve execution time. Write the entire code and no other text in the response.\n\n### Concepts:\n[-] isReachable\n[-] java.net.InetAddress\n[+] java.net.InetSocketAddress\n[+] java.net.Socket\n[+] setPerformancePreferences\n[+] TCP_NODELAY\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\n\npublic class ScanHostsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanHostsRunnable\";\n\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.start; i <= this.stop; i++) {\n            String newIp = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                InetAddress address = InetAddress.getByName(newIp);\n                address.isReachable(100);\n            }\n            catch(IOException ignored) {\n            }\n            finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanHostsRunnable\";\n\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String newIp = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try (Socket socket = new Socket()) {\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(newIp, 80), 100); \/\/ Connect to port 80 with a timeout\n                this.delegate.processFinish(1); \/\/ Host is reachable\n            } catch (IOException ignored) {\n                \/\/ Host is not reachable\n            }\n        }\n    }\n}\n```"]}
{"non_functional_requirement":"executiontime","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/e37a1a522a15773710f051d9fff5c0ce68ade5cb","commit_message":"'\\\\\"Java can often do more optimizations to things outside of try blocks. Take more advantage of the JIT\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                Socket socket = new Socket();\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}","target_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport android.util.Log;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void run() {\n        for(int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(0);\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n                socket.close();\n                this.delegate.processFinish(i);\n            }\n            catch(SocketException e) {\n                Log.e(TAG, e.getMessage());\n            }\n            catch(IOException e) {\n                Log.e(TAG, e.getMessage());\n            }\n        }\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport android.util.Log;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void run() {\n        for(int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(0);\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n                socket.close();\n                this.delegate.processFinish(i);\n            }\n            catch(SocketException e) {\n                Log.e(TAG, e.getMessage());\n            }\n            catch(IOException e) {\n                Log.e(TAG, e.getMessage());\n            }\n        }\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport android.util.Log;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void run() {\n        for(int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(0);\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 4000);\n                socket.close();\n                this.delegate.processFinish(i);\n            }\n            catch(SocketException e) {\n                Log.e(TAG, e.getMessage());\n            }\n            catch(IOException e) {\n                Log.e(TAG, e.getMessage());\n            }\n        }\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport android.util.Log;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.SocketException;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    @Override\n    public void run() {\n        for(int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(0);\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n                socket.close();\n                this.delegate.processFinish(i);\n            }\n            catch(SocketException e) {\n                Log.e(TAG, e.getMessage());\n            }\n            catch(IOException e) {\n                Log.e(TAG, e.getMessage());\n            }\n        }\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the run function to improve execution time. Write the entire code and no other text in the response.\n\n### Concepts:\n  [+] statements inside vs outside try...finally block\n[hint] moving statements outside try...finally blocks enables optimizations\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                Socket socket = new Socket();\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            try {\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n            } catch (IOException ignored) {\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException ignored) {\n                }\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n```"]}
{"non_functional_requirement":"executiontime","commit":"https:\/\/github.com\/vaginessa\/TestBrowser-Lightning\/commit\/d68ab94bbb4ac5a4ccdca5771b5c12603773b125","commit_message":"'\\\\\"Optimize LicenseActivity\\\\n\\\\\"'","source_code":"\/*\n * Copyright 2014 A.C.R. Development\n *\/\npackage acr.browser.lightning;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.LinearLayout;\n\n\/*\n *NOTE: This activity must not be removed in order to comply with the Mozilla Public License v. 2.0 \n *under which this code is licensed. Unless you plan on providing other attribution in the app to \n *the original source in another visible way, it is advised against the removal of this Activity.\n *\/\npublic class LicenseActivity extends Activity {\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.license_activity);\n\t\tgetActionBar().setHomeButtonEnabled(true);\n\t\tgetActionBar().setDisplayHomeAsUpEnabled(true);\n\t\tLinearLayout thunder = (LinearLayout) findViewById(R.id.browserLicense);\n\t\tLinearLayout aosp = (LinearLayout) findViewById(R.id.licenseAOSP);\n\t\tLinearLayout hosts = (LinearLayout) findViewById(R.id.licenseHosts);\n\t\tthunder.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/www.mozilla.org\/MPL\/2.0\/\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\t\taosp.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/www.apache.org\/licenses\/LICENSE-2.0\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\t\t\n\t\thosts.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/hosts-file.net\/\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tfinish();\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n}\n","target_code":"\/*\n * Copyright 2014 A.C.R. Development\n *\/\npackage acr.browser.lightning;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport android.view.View;\n\n\/*\n *NOTE: This activity must not be removed in order to comply with the Mozilla Public License v. 2.0 \n *under which this code is licensed. Unless you plan on providing other attribution in the app to \n *the original source in another visible way, it is advised against the removal of this Activity.\n *\/\npublic class LicenseActivity extends Activity implements View.OnClickListener {\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.license_activity);\n\t\tgetActionBar().setHomeButtonEnabled(true);\n\t\tgetActionBar().setDisplayHomeAsUpEnabled(true);\n\t\tfindViewById(R.id.browserLicense).setOnClickListener(this);\n\t\tfindViewById(R.id.licenseAOSP).setOnClickListener(this);\n\t\tfindViewById(R.id.licenseHosts).setOnClickListener(this);\n\t}\n\t\n\t@Override\n    public void onClick(View v) {\n\t    switch (v.getId()) {\n\t        case R.id.browserLicense:\n                actionView(\"http:\/\/www.mozilla.org\/MPL\/2.0\/\");\n                break;\n\t        case R.id.licenseAOSP:\n\t            actionView(\"http:\/\/www.apache.org\/licenses\/LICENSE-2.0\");\n                break;\n\t        case R.id.licenseHosts:\n\t            actionView(\"http:\/\/hosts-file.net\/\");\n                break;\n        }\n    }\n\t\n\tprivate void actionView(String url) {\n\t    startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));\n        finish();\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tfinish();\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanHostsRunnable\";\n\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.start; i <= this.stop; i++) {\n            String newIp = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(newIp, 7), 100);\n            }\n            catch(IOException ignored) {\n            }\n            finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\n\npublic class ScanHostsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanHostsRunnable\";\n\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.start; i <= this.stop; i++) {\n            String newIp = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                InetAddress address = InetAddress.getByName(newIp);\n                address.isReachable(100);\n            }\n            catch(IOException ignored) {\n            }\n            finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\n\npublic class ScanHostsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanHostsRunnable\";\n\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.start; i <= this.stop; i++) {\n            String newIp = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                InetAddress address = InetAddress.getByName(newIp);\n                address.isReachable(100);\n            }\n            catch(IOException ignored) {\n            }\n            finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanHostsRunnable\";\n\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.start; i <= this.stop; i++) {\n            String newIp = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(newIp, 7), 100);\n            }\n            catch(IOException ignored) {\n            }\n            finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite LicenseActivity class to improve execution time. Write the entire code and no other text in the response.\n\n### Concepts:\n[implement] View.OnClickListener\n[override] onClick and actionView functions\n[-] android.view.View.OnClickListener\n[-] android.widget.LinearLayout\n\n### Given program:\n```java\n\/*\n * Copyright 2014 A.C.R. Development\n *\/\npackage acr.browser.lightning;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.LinearLayout;\n\n\/*\n *NOTE: This activity must not be removed in order to comply with the Mozilla Public License v. 2.0 \n *under which this code is licensed. Unless you plan on providing other attribution in the app to \n *the original source in another visible way, it is advised against the removal of this Activity.\n *\/\npublic class LicenseActivity extends Activity {\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.license_activity);\n\t\tgetActionBar().setHomeButtonEnabled(true);\n\t\tgetActionBar().setDisplayHomeAsUpEnabled(true);\n\t\tLinearLayout thunder = (LinearLayout) findViewById(R.id.browserLicense);\n\t\tLinearLayout aosp = (LinearLayout) findViewById(R.id.licenseAOSP);\n\t\tLinearLayout hosts = (LinearLayout) findViewById(R.id.licenseHosts);\n\t\tthunder.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/www.mozilla.org\/MPL\/2.0\/\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\t\taosp.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/www.apache.org\/licenses\/LICENSE-2.0\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\t\t\n\t\thosts.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/hosts-file.net\/\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tfinish();\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n}\n\n```\n\n### Response:\n```java\n```java\n\/*\n * Copyright 2014 A.C.R. Development\n *\/\npackage acr.browser.lightning;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport android.view.View;\n\npublic class LicenseActivity extends Activity implements View.OnClickListener {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.license_activity);\n        getActionBar().setHomeButtonEnabled(true);\n        getActionBar().setDisplayHomeAsUpEnabled(true);\n        \n        findViewById(R.id.browserLicense).setOnClickListener(this);\n        findViewById(R.id.licenseAOSP).setOnClickListener(this);\n        findViewById(R.id.licenseHosts).setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.browserLicense:\n                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(\"http:\/\/www.mozilla.org\/MPL\/2.0\/\")));\n                break;\n            case R.id.licenseAOSP:\n                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(\"http:\/\/www.apache.org\/licenses\/LICENSE-2.0\")));\n                break;\n            case R.id.licenseHosts:\n                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(\"http:\/\/hosts-file.net\/\")));\n                break;\n        }\n        finish();\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        finish();\n        return super.onOptionsItemSelected(item);\n    }\n}\n```"]}
{"non_functional_requirement":"executiontime","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/0eb3cc570e3898cf681d12cf399ab040aea16e8f","commit_message":"'\\\\\"For larger scans a fixed thread pool provides better performance\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newCachedThreadPool();\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n","target_code":"package com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                Socket socket = new Socket();\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            try {\n                Socket socket = new Socket();\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nCode-B:\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.MainAsyncResponse;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\n\npublic class ScanHostsRunnable implements Runnable {\n    private String[] ipParts;\n    private int start;\n    private int stop;\n    private MainAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to scan for hosts\n     *\n     * @param ipParts  IP address split up by the segments\n     * @param start    Host to start scanning at\n     * @param stop     Host to stop scanning at\n     * @param delegate Called when host discovery has finished\n     *\/\n    public ScanHostsRunnable(String[] ipParts, int start, int stop, MainAsyncResponse delegate) {\n        this.ipParts = ipParts;\n        this.start = start;\n        this.stop = stop;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the host discovery\n     *\/\n    @Override\n    public void run() {\n        for (int i = this.start; i <= this.stop; i++) {\n            String ip = this.ipParts[0] + \".\" + this.ipParts[1] + \".\" + this.ipParts[2] + \".\" + i;\n            Socket socket = new Socket();\n            socket.setPerformancePreferences(1, 0, 0);\n\n            try {\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(ip, 7), 250);\n                socket.close();\n            } catch (IOException ignored) {\n            } finally {\n                this.delegate.processFinish(1);\n            }\n        }\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the code to improve execution time for larger scans. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] Fixed size thread pool\n[in] doInBackground function\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newCachedThreadPool();\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort + 1) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop;\n\n        for (int i = 0; i < NUM_THREADS; i++) {\n            previousStop = Math.min(previousStart + chunk - 1, stopPort);\n            if (previousStart > stopPort) {\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        } catch (InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n```"]}
{"non_functional_requirement":"executiontime","commit":"https:\/\/github.com\/erikusaj\/fdroidTvClient\/commit\/e085e0392bfb5b476ab114382663a7ca7fd5ce4e","commit_message":"'\\\\\"PackageReceiver: Only fetch the one PackageInfo\\\\n\\\\nWe were fetching information on all installed packages and doing a linear\\\\nsearch. Which is silly and inefficient since we can directly fetch information\\\\non a single installed package by id.\\\\n\\\\\"'","source_code":"\/*\n * Copyright (C) 2014  Ciaran Gultnieks, ciaran@ciarang.com,\n * Peter Serwylo, peter@serwylo.com\n *\n * This program is free software; you can redistribute it and\/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\/\n\npackage org.fdroid.fdroid.receiver;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.data.ApkProvider;\nimport org.fdroid.fdroid.data.AppProvider;\n\nabstract class PackageReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"PackageReceiver\";\n\n    protected abstract boolean toDiscard(Intent intent);\n\n    protected abstract void handle(Context context, String appId);\n\n    protected PackageInfo getPackageInfo(Context context, String appId) {\n        for (PackageInfo info : context.getPackageManager().getInstalledPackages(0)) {\n            if (info.packageName.equals(appId)) {\n                return info;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Utils.debugLog(TAG, \"PackageReceiver received [action = '\" + intent.getAction() + \"', data = '\" + intent.getData() + \"']\");\n        if (toDiscard(intent)) {\n            return;\n        }\n        String appId = intent.getData().getSchemeSpecificPart();\n        handle(context, appId);\n        context.getContentResolver().notifyChange(AppProvider.getContentUri(appId), null);\n        context.getContentResolver().notifyChange(ApkProvider.getAppUri(appId), null);\n    }\n\n}\n","target_code":"\/*\n * Copyright (C) 2014  Ciaran Gultnieks, ciaran@ciarang.com,\n * Peter Serwylo, peter@serwylo.com\n *\n * This program is free software; you can redistribute it and\/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\/\n\npackage org.fdroid.fdroid.receiver;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.data.ApkProvider;\nimport org.fdroid.fdroid.data.AppProvider;\n\nabstract class PackageReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"PackageReceiver\";\n\n    protected abstract boolean toDiscard(Intent intent);\n\n    protected abstract void handle(Context context, String appId);\n\n    protected PackageInfo getPackageInfo(Context context, String appId) {\n        PackageInfo info = null;\n        try {\n            info = context.getPackageManager().getPackageInfo(appId, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            \/\/ ignore\n        }\n        return info;\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Utils.debugLog(TAG, \"PackageReceiver received [action = '\" + intent.getAction() + \"', data = '\" + intent.getData() + \"']\");\n        if (toDiscard(intent)) {\n            return;\n        }\n        String appId = intent.getData().getSchemeSpecificPart();\n        handle(context, appId);\n        context.getContentResolver().notifyChange(AppProvider.getContentUri(appId), null);\n        context.getContentResolver().notifyChange(ApkProvider.getAppUri(appId), null);\n    }\n\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\n\/*\n * Copyright 2014 A.C.R. Development\n *\/\npackage acr.browser.lightning;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport android.view.View;\n\n\/*\n *NOTE: This activity must not be removed in order to comply with the Mozilla Public License v. 2.0 \n *under which this code is licensed. Unless you plan on providing other attribution in the app to \n *the original source in another visible way, it is advised against the removal of this Activity.\n *\/\npublic class LicenseActivity extends Activity implements View.OnClickListener {\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.license_activity);\n\t\tgetActionBar().setHomeButtonEnabled(true);\n\t\tgetActionBar().setDisplayHomeAsUpEnabled(true);\n\t\tfindViewById(R.id.browserLicense).setOnClickListener(this);\n\t\tfindViewById(R.id.licenseAOSP).setOnClickListener(this);\n\t\tfindViewById(R.id.licenseHosts).setOnClickListener(this);\n\t}\n\t\n\t@Override\n    public void onClick(View v) {\n\t    switch (v.getId()) {\n\t        case R.id.browserLicense:\n                actionView(\"http:\/\/www.mozilla.org\/MPL\/2.0\/\");\n                break;\n\t        case R.id.licenseAOSP:\n\t            actionView(\"http:\/\/www.apache.org\/licenses\/LICENSE-2.0\");\n                break;\n\t        case R.id.licenseHosts:\n\t            actionView(\"http:\/\/hosts-file.net\/\");\n                break;\n        }\n    }\n\t\n\tprivate void actionView(String url) {\n\t    startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));\n        finish();\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tfinish();\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n}\n\n\nCode-B:\n\/*\n * Copyright 2014 A.C.R. Development\n *\/\npackage acr.browser.lightning;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.LinearLayout;\n\n\/*\n *NOTE: This activity must not be removed in order to comply with the Mozilla Public License v. 2.0 \n *under which this code is licensed. Unless you plan on providing other attribution in the app to \n *the original source in another visible way, it is advised against the removal of this Activity.\n *\/\npublic class LicenseActivity extends Activity {\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.license_activity);\n\t\tgetActionBar().setHomeButtonEnabled(true);\n\t\tgetActionBar().setDisplayHomeAsUpEnabled(true);\n\t\tLinearLayout thunder = (LinearLayout) findViewById(R.id.browserLicense);\n\t\tLinearLayout aosp = (LinearLayout) findViewById(R.id.licenseAOSP);\n\t\tLinearLayout hosts = (LinearLayout) findViewById(R.id.licenseHosts);\n\t\tthunder.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/www.mozilla.org\/MPL\/2.0\/\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\t\taosp.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/www.apache.org\/licenses\/LICENSE-2.0\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\t\t\n\t\thosts.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/hosts-file.net\/\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tfinish();\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\n\/*\n * Copyright 2014 A.C.R. Development\n *\/\npackage acr.browser.lightning;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.LinearLayout;\n\n\/*\n *NOTE: This activity must not be removed in order to comply with the Mozilla Public License v. 2.0 \n *under which this code is licensed. Unless you plan on providing other attribution in the app to \n *the original source in another visible way, it is advised against the removal of this Activity.\n *\/\npublic class LicenseActivity extends Activity {\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.license_activity);\n\t\tgetActionBar().setHomeButtonEnabled(true);\n\t\tgetActionBar().setDisplayHomeAsUpEnabled(true);\n\t\tLinearLayout thunder = (LinearLayout) findViewById(R.id.browserLicense);\n\t\tLinearLayout aosp = (LinearLayout) findViewById(R.id.licenseAOSP);\n\t\tLinearLayout hosts = (LinearLayout) findViewById(R.id.licenseHosts);\n\t\tthunder.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/www.mozilla.org\/MPL\/2.0\/\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\t\taosp.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/www.apache.org\/licenses\/LICENSE-2.0\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\t\t\n\t\thosts.setOnClickListener(new OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tstartActivity(new Intent(Intent.ACTION_VIEW, Uri\n\t\t\t\t\t\t.parse(\"http:\/\/hosts-file.net\/\")));\n\t\t\t\tfinish();\n\t\t\t}\n\n\t\t});\n\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tfinish();\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n}\n\n\nCode-B:\n\/*\n * Copyright 2014 A.C.R. Development\n *\/\npackage acr.browser.lightning;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport android.view.View;\n\n\/*\n *NOTE: This activity must not be removed in order to comply with the Mozilla Public License v. 2.0 \n *under which this code is licensed. Unless you plan on providing other attribution in the app to \n *the original source in another visible way, it is advised against the removal of this Activity.\n *\/\npublic class LicenseActivity extends Activity implements View.OnClickListener {\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.license_activity);\n\t\tgetActionBar().setHomeButtonEnabled(true);\n\t\tgetActionBar().setDisplayHomeAsUpEnabled(true);\n\t\tfindViewById(R.id.browserLicense).setOnClickListener(this);\n\t\tfindViewById(R.id.licenseAOSP).setOnClickListener(this);\n\t\tfindViewById(R.id.licenseHosts).setOnClickListener(this);\n\t}\n\t\n\t@Override\n    public void onClick(View v) {\n\t    switch (v.getId()) {\n\t        case R.id.browserLicense:\n                actionView(\"http:\/\/www.mozilla.org\/MPL\/2.0\/\");\n                break;\n\t        case R.id.licenseAOSP:\n\t            actionView(\"http:\/\/www.apache.org\/licenses\/LICENSE-2.0\");\n                break;\n\t        case R.id.licenseHosts:\n\t            actionView(\"http:\/\/hosts-file.net\/\");\n                break;\n        }\n    }\n\t\n\tprivate void actionView(String url) {\n\t    startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));\n        finish();\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tfinish();\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the code to improve execution time. Write the entire code and no other text in the response.\n\n### Concepts:\n[-] linear search\n[+] android.content.pm.PackageManager.getPackageInfo (string, int)\n\n### Given program:\n```java\n\/*\n * Copyright (C) 2014  Ciaran Gultnieks, ciaran@ciarang.com,\n * Peter Serwylo, peter@serwylo.com\n *\n * This program is free software; you can redistribute it and\/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\/\n\npackage org.fdroid.fdroid.receiver;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.data.ApkProvider;\nimport org.fdroid.fdroid.data.AppProvider;\n\nabstract class PackageReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"PackageReceiver\";\n\n    protected abstract boolean toDiscard(Intent intent);\n\n    protected abstract void handle(Context context, String appId);\n\n    protected PackageInfo getPackageInfo(Context context, String appId) {\n        for (PackageInfo info : context.getPackageManager().getInstalledPackages(0)) {\n            if (info.packageName.equals(appId)) {\n                return info;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Utils.debugLog(TAG, \"PackageReceiver received [action = '\" + intent.getAction() + \"', data = '\" + intent.getData() + \"']\");\n        if (toDiscard(intent)) {\n            return;\n        }\n        String appId = intent.getData().getSchemeSpecificPart();\n        handle(context, appId);\n        context.getContentResolver().notifyChange(AppProvider.getContentUri(appId), null);\n        context.getContentResolver().notifyChange(ApkProvider.getAppUri(appId), null);\n    }\n\n}\n\n```\n\n### Response:\n```java\n```java\n\/*\n * Copyright (C) 2014  Ciaran Gultnieks, ciaran@ciarang.com,\n * Peter Serwylo, peter@serwylo.com\n *\n * This program is free software; you can redistribute it and\/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\/\n\npackage org.fdroid.fdroid.receiver;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.data.ApkProvider;\nimport org.fdroid.fdroid.data.AppProvider;\n\nabstract class PackageReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"PackageReceiver\";\n\n    protected abstract boolean toDiscard(Intent intent);\n\n    protected abstract void handle(Context context, String appId);\n\n    protected PackageInfo getPackageInfo(Context context, String appId) {\n        try {\n            return context.getPackageManager().getPackageInfo(appId, 0);\n        } catch (android.content.pm.PackageManager.NameNotFoundException e) {\n            return null;\n        }\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Utils.debugLog(TAG, \"PackageReceiver received [action = '\" + intent.getAction() + \"', data = '\" + intent.getData() + \"']\");\n        if (toDiscard(intent)) {\n            return;\n        }\n        String appId = intent.getData().getSchemeSpecificPart();\n        handle(context, appId);\n        context.getContentResolver().notifyChange(AppProvider.getContentUri(appId), null);\n        context.getContentResolver().notifyChange(ApkProvider.getAppUri(appId), null);\n    }\n\n}\n```"]}
{"non_functional_requirement":"executiontime","commit":"https:\/\/github.com\/ThaiCao\/EasyWatermark\/commit\/b822502acf65173418081102a04c7faabb632379","commit_message":"'\\\\\":zap: :bug:\\\\n[Update]\\\\n- Optimize logo view performance.\\\\n[Fix]\\\\n- Fix the flash problem when the animation ends\\\\n\\\\\"'","source_code":"package me.rosuh.easywatermark.widget\n\nimport android.animation.ObjectAnimator\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.graphics.*\nimport android.util.AttributeSet\nimport androidx.appcompat.widget.AppCompatImageView\nimport androidx.core.graphics.drawable.toBitmap\nimport androidx.interpolator.view.animation.FastOutLinearInInterpolator\n\n\nclass ColoredImageVIew : AppCompatImageView {\n    constructor(context: Context) : super(context)\n    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    )\n\n    private val paint by lazy { Paint() }\n\n    private val colorList = arrayOf(\n        Color.parseColor(\"#FFA51F\"),\n        Color.parseColor(\"#FFD703\"),\n        Color.parseColor(\"#C0FF39\"),\n        Color.parseColor(\"#00FFE0\")\n    ).toIntArray()\n\n    private val posList = arrayOf(0f, 0.5178f, 0.7654f, 1f).toFloatArray()\n\n    private val colorAnimator by lazy {\n        ObjectAnimator.ofFloat(1f, 0f)\n            .apply {\n                addUpdateListener {\n                    val pos = (it.animatedValue as Float)\n                    val shader = LinearGradient(\n                        (1 - pos) * width.toFloat() * 2f,\n                        pos * height.toFloat(),\n                        0f,\n                        height.toFloat(),\n                        colorList,\n                        posList,\n                        Shader.TileMode.CLAMP\n                    )\n                    paint.shader = shader\n                    postInvalidateOnAnimation()\n                }\n                duration = 1200\n                interpolator = FastOutLinearInInterpolator()\n                repeatCount = ObjectAnimator.INFINITE\n                repeatMode = ObjectAnimator.REVERSE\n            }\n    }\n\n\n    private var innerBitmap: Bitmap? = null\n\n    @SuppressLint(\"DrawAllocation\")\n    override fun onDraw(canvas: Canvas?) {\n        if (innerBitmap == null) {\n            super.onDraw(canvas)\n            innerBitmap = drawable.toBitmap(width, height)\n        }\n        innerBitmap?.let {\n            val sc = canvas?.saveLayer(0f, 0f, width.toFloat(), height.toFloat(), null) ?: return\n            canvas.drawBitmap(it, 0f, 0f, paint)\n            paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP)\n            canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint)\n            paint.xfermode = null\n            canvas.restoreToCount(sc)\n        }\n    }\n\n\n    fun start() {\n        colorAnimator.start()\n    }\n\n    fun stop() {\n        colorAnimator.pause()\n    }\n}","target_code":"package me.rosuh.easywatermark.widget\n\nimport android.animation.ObjectAnimator\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.graphics.*\nimport android.util.AttributeSet\nimport androidx.appcompat.widget.AppCompatImageView\nimport androidx.core.graphics.drawable.toBitmap\n\n\nclass ColoredImageVIew : AppCompatImageView {\n    constructor(context: Context) : super(context)\n    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    )\n\n    private var sizeHasChanged: Boolean = true\n    private val paint by lazy { Paint() }\n\n    private val colorList = arrayOf(\n        Color.parseColor(\"#FFA51F\"),\n        Color.parseColor(\"#FFD703\"),\n        Color.parseColor(\"#C0FF39\"),\n        Color.parseColor(\"#00FFE0\")\n    ).toIntArray()\n\n    private val posList = arrayOf(0f, 0.5178f, 0.7654f, 1f).toFloatArray()\n\n    private val xfermode by lazy { PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP) }\n\n    private val colorAnimator by lazy {\n        ObjectAnimator.ofFloat(1f, 0f)\n            .apply {\n                addUpdateListener {\n                    val pos = (it.animatedValue as Float)\n                    val shader = LinearGradient(\n                        (1 - pos) * width.toFloat() * 2f,\n                        pos * height.toFloat(),\n                        0f,\n                        height.toFloat(),\n                        colorList,\n                        posList,\n                        Shader.TileMode.CLAMP\n                    )\n                    paint.shader = shader\n                    postInvalidateOnAnimation()\n                }\n                duration = 1200\n                repeatCount = ObjectAnimator.INFINITE\n                repeatMode = ObjectAnimator.REVERSE\n            }\n    }\n\n\n    private var innerBitmap: Bitmap? = null\n\n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n        sizeHasChanged = w != oldh || h != oldh\n    }\n\n    @SuppressLint(\"DrawAllocation\")\n    override fun onDraw(canvas: Canvas?) {\n        if (innerBitmap == null || sizeHasChanged) {\n            super.onDraw(canvas)\n            innerBitmap = drawable.toBitmap(width, height)\n        }\n        innerBitmap?.let {\n            val sc = canvas?.saveLayer(0f, 0f, width.toFloat(), height.toFloat(), null) ?: return\n            canvas.drawBitmap(it, 0f, 0f, paint)\n            paint.xfermode = xfermode\n            canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint)\n            paint.xfermode = null\n            canvas.restoreToCount(sc)\n        }\n    }\n\n\n    fun start() {\n        colorAnimator.start()\n    }\n\n    fun stop() {\n        colorAnimator.pause()\n    }\n}","pl":"Kotlin","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newCachedThreadPool();\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newCachedThreadPool();\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.async;\n\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n\n    private static final String TAG = \"ScanPortsAsyncTask\";\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     * @return\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        final int NUM_THREADS = 500;\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);\n\n        int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n        int previousStart = startPort;\n        int previousStop = (startPort - 1) + chunk;\n\n        for(int i = 0; i < NUM_THREADS; i++) {\n            if(previousStop >= stopPort) {\n                previousStop = stopPort;\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                break;\n            }\n            executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n            previousStart = previousStop + 1;\n            previousStop = previousStop + chunk;\n        }\n\n        executor.shutdown();\n\n        try {\n            executor.awaitTermination(10, TimeUnit.MINUTES);\n        }\n        catch(InterruptedException ignored) {\n        }\n\n        this.delegate.processFinish(true);\n\n        return null;\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the code to optimize logo view performance and user experience of the android application. Write the entire code and no other text in the response.\n\n### Concepts:\n[-] androidx.interpolator.view.animation.FastOutLinearInInterpolator\n[override] onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int)\n\n### Given program:\n```kotlin\npackage me.rosuh.easywatermark.widget\n\nimport android.animation.ObjectAnimator\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.graphics.*\nimport android.util.AttributeSet\nimport androidx.appcompat.widget.AppCompatImageView\nimport androidx.core.graphics.drawable.toBitmap\nimport androidx.interpolator.view.animation.FastOutLinearInInterpolator\n\n\nclass ColoredImageVIew : AppCompatImageView {\n    constructor(context: Context) : super(context)\n    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    )\n\n    private val paint by lazy { Paint() }\n\n    private val colorList = arrayOf(\n        Color.parseColor(\"#FFA51F\"),\n        Color.parseColor(\"#FFD703\"),\n        Color.parseColor(\"#C0FF39\"),\n        Color.parseColor(\"#00FFE0\")\n    ).toIntArray()\n\n    private val posList = arrayOf(0f, 0.5178f, 0.7654f, 1f).toFloatArray()\n\n    private val colorAnimator by lazy {\n        ObjectAnimator.ofFloat(1f, 0f)\n            .apply {\n                addUpdateListener {\n                    val pos = (it.animatedValue as Float)\n                    val shader = LinearGradient(\n                        (1 - pos) * width.toFloat() * 2f,\n                        pos * height.toFloat(),\n                        0f,\n                        height.toFloat(),\n                        colorList,\n                        posList,\n                        Shader.TileMode.CLAMP\n                    )\n                    paint.shader = shader\n                    postInvalidateOnAnimation()\n                }\n                duration = 1200\n                interpolator = FastOutLinearInInterpolator()\n                repeatCount = ObjectAnimator.INFINITE\n                repeatMode = ObjectAnimator.REVERSE\n            }\n    }\n\n\n    private var innerBitmap: Bitmap? = null\n\n    @SuppressLint(\"DrawAllocation\")\n    override fun onDraw(canvas: Canvas?) {\n        if (innerBitmap == null) {\n            super.onDraw(canvas)\n            innerBitmap = drawable.toBitmap(width, height)\n        }\n        innerBitmap?.let {\n            val sc = canvas?.saveLayer(0f, 0f, width.toFloat(), height.toFloat(), null) ?: return\n            canvas.drawBitmap(it, 0f, 0f, paint)\n            paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP)\n            canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint)\n            paint.xfermode = null\n            canvas.restoreToCount(sc)\n        }\n    }\n\n\n    fun start() {\n        colorAnimator.start()\n    }\n\n    fun stop() {\n        colorAnimator.pause()\n    }\n}\n```\n\n### Response:\n```kotlin\n```kotlin\npackage me.rosuh.easywatermark.widget\n\nimport android.animation.ObjectAnimator\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.graphics.*\nimport android.util.AttributeSet\nimport androidx.appcompat.widget.AppCompatImageView\nimport androidx.core.graphics.drawable.toBitmap\n\nclass ColoredImageView : AppCompatImageView {\n    constructor(context: Context) : super(context)\n    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    )\n\n    private val paint by lazy { Paint() }\n\n    private val colorList = arrayOf(\n        Color.parseColor(\"#FFA51F\"),\n        Color.parseColor(\"#FFD703\"),\n        Color.parseColor(\"#C0FF39\"),\n        Color.parseColor(\"#00FFE0\")\n    ).toIntArray()\n\n    private val posList = arrayOf(0f, 0.5178f, 0.7654f, 1f).toFloatArray()\n\n    private val colorAnimator by lazy {\n        ObjectAnimator.ofFloat(1f, 0f)\n            .apply {\n                addUpdateListener {\n                    val pos = (it.animatedValue as Float)\n                    val shader = LinearGradient(\n                        (1 - pos) * width.toFloat() * 2f,\n                        pos * height.toFloat(),\n                        0f,\n                        height.toFloat(),\n                        colorList,\n                        posList,\n                        Shader.TileMode.CLAMP\n                    )\n                    paint.shader = shader\n                    invalidate()\n                }\n                duration = 1200\n                repeatCount = ObjectAnimator.INFINITE\n                repeatMode = ObjectAnimator.REVERSE\n            }\n    }\n\n    private var innerBitmap: Bitmap? = null\n\n    @SuppressLint(\"DrawAllocation\")\n    override fun onDraw(canvas: Canvas?) {\n        if (innerBitmap == null) {\n            innerBitmap = drawable.toBitmap(width, height)\n        }\n        innerBitmap?.let {\n            val sc = canvas?.saveLayer(0f, 0f, width.toFloat(), height.toFloat(), null) ?: return\n            canvas.drawBitmap(it, 0f, 0f, paint)\n            paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP)\n            canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint)\n            paint.xfermode = null\n            canvas.restoreToCount(sc)\n        }\n    }\n\n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n        innerBitmap = drawable.toBitmap(w, h)\n    }\n\n    fun start() {\n        colorAnimator.start()\n    }\n\n    fun stop() {\n        colorAnimator.pause()\n    }\n}\n```"]}
{"non_functional_requirement":"executiontime","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/ef46ba248bd73d52e071e53e9352e9cc0cd3694b","commit_message":"'\\\\\"Reduce timeout\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.async;\n\nimport android.content.Context;\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\nimport com.aaronjwood.portauthority.utils.UserPreference;\n\nimport java.lang.ref.WeakReference;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n    private final WeakReference<HostAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        HostAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            Context context = (Context) activity;\n            final int NUM_THREADS = UserPreference.getPortScanThreads(context);\n\n            try {\n                InetAddress address = InetAddress.getByName(ip);\n                ip = address.getHostAddress();\n            } catch (UnknownHostException e) {\n                activity.processFinish(false);\n                return null;\n            }\n\n            ExecutorService executor = Executors.newCachedThreadPool();\n\n            int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n            int previousStart = startPort;\n            int previousStop = (startPort - 1) + chunk;\n\n            for (int i = 0; i < NUM_THREADS; i++) {\n                if (previousStop >= stopPort) {\n                    previousStop = stopPort;\n                    executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                    break;\n                }\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                previousStart = previousStop + 1;\n                previousStop = previousStop + chunk;\n            }\n\n            executor.shutdown();\n\n            try {\n                executor.awaitTermination(10, TimeUnit.MINUTES);\n            } catch (InterruptedException ignored) {\n            }\n\n            activity.processFinish(true);\n        }\n\n        return null;\n    }\n}\n","target_code":"package com.aaronjwood.portauthority.async;\n\nimport android.content.Context;\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\nimport com.aaronjwood.portauthority.utils.UserPreference;\n\nimport java.lang.ref.WeakReference;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n    private final WeakReference<HostAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        HostAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            Context context = (Context) activity;\n            final int NUM_THREADS = UserPreference.getPortScanThreads(context);\n\n            try {\n                InetAddress address = InetAddress.getByName(ip);\n                ip = address.getHostAddress();\n            } catch (UnknownHostException e) {\n                activity.processFinish(false);\n                return null;\n            }\n\n            ExecutorService executor = Executors.newCachedThreadPool();\n\n            int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n            int previousStart = startPort;\n            int previousStop = (startPort - 1) + chunk;\n\n            for (int i = 0; i < NUM_THREADS; i++) {\n                if (previousStop >= stopPort) {\n                    previousStop = stopPort;\n                    executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                    break;\n                }\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                previousStart = previousStop + 1;\n                previousStop = previousStop + chunk;\n            }\n\n            executor.shutdown();\n\n            try {\n                executor.awaitTermination(5, TimeUnit.MINUTES);\n            } catch (InterruptedException ignored) {\n            }\n\n            activity.processFinish(true);\n        }\n\n        return null;\n    }\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\n\/*\n * Copyright (C) 2014  Ciaran Gultnieks, ciaran@ciarang.com,\n * Peter Serwylo, peter@serwylo.com\n *\n * This program is free software; you can redistribute it and\/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\/\n\npackage org.fdroid.fdroid.receiver;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.data.ApkProvider;\nimport org.fdroid.fdroid.data.AppProvider;\n\nabstract class PackageReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"PackageReceiver\";\n\n    protected abstract boolean toDiscard(Intent intent);\n\n    protected abstract void handle(Context context, String appId);\n\n    protected PackageInfo getPackageInfo(Context context, String appId) {\n        PackageInfo info = null;\n        try {\n            info = context.getPackageManager().getPackageInfo(appId, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            \/\/ ignore\n        }\n        return info;\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Utils.debugLog(TAG, \"PackageReceiver received [action = '\" + intent.getAction() + \"', data = '\" + intent.getData() + \"']\");\n        if (toDiscard(intent)) {\n            return;\n        }\n        String appId = intent.getData().getSchemeSpecificPart();\n        handle(context, appId);\n        context.getContentResolver().notifyChange(AppProvider.getContentUri(appId), null);\n        context.getContentResolver().notifyChange(ApkProvider.getAppUri(appId), null);\n    }\n\n}\n\n\nCode-B:\n\/*\n * Copyright (C) 2014  Ciaran Gultnieks, ciaran@ciarang.com,\n * Peter Serwylo, peter@serwylo.com\n *\n * This program is free software; you can redistribute it and\/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\/\n\npackage org.fdroid.fdroid.receiver;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.data.ApkProvider;\nimport org.fdroid.fdroid.data.AppProvider;\n\nabstract class PackageReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"PackageReceiver\";\n\n    protected abstract boolean toDiscard(Intent intent);\n\n    protected abstract void handle(Context context, String appId);\n\n    protected PackageInfo getPackageInfo(Context context, String appId) {\n        for (PackageInfo info : context.getPackageManager().getInstalledPackages(0)) {\n            if (info.packageName.equals(appId)) {\n                return info;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Utils.debugLog(TAG, \"PackageReceiver received [action = '\" + intent.getAction() + \"', data = '\" + intent.getData() + \"']\");\n        if (toDiscard(intent)) {\n            return;\n        }\n        String appId = intent.getData().getSchemeSpecificPart();\n        handle(context, appId);\n        context.getContentResolver().notifyChange(AppProvider.getContentUri(appId), null);\n        context.getContentResolver().notifyChange(ApkProvider.getAppUri(appId), null);\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\n\/*\n * Copyright (C) 2014  Ciaran Gultnieks, ciaran@ciarang.com,\n * Peter Serwylo, peter@serwylo.com\n *\n * This program is free software; you can redistribute it and\/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\/\n\npackage org.fdroid.fdroid.receiver;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.data.ApkProvider;\nimport org.fdroid.fdroid.data.AppProvider;\n\nabstract class PackageReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"PackageReceiver\";\n\n    protected abstract boolean toDiscard(Intent intent);\n\n    protected abstract void handle(Context context, String appId);\n\n    protected PackageInfo getPackageInfo(Context context, String appId) {\n        for (PackageInfo info : context.getPackageManager().getInstalledPackages(0)) {\n            if (info.packageName.equals(appId)) {\n                return info;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Utils.debugLog(TAG, \"PackageReceiver received [action = '\" + intent.getAction() + \"', data = '\" + intent.getData() + \"']\");\n        if (toDiscard(intent)) {\n            return;\n        }\n        String appId = intent.getData().getSchemeSpecificPart();\n        handle(context, appId);\n        context.getContentResolver().notifyChange(AppProvider.getContentUri(appId), null);\n        context.getContentResolver().notifyChange(ApkProvider.getAppUri(appId), null);\n    }\n\n}\n\n\nCode-B:\n\/*\n * Copyright (C) 2014  Ciaran Gultnieks, ciaran@ciarang.com,\n * Peter Serwylo, peter@serwylo.com\n *\n * This program is free software; you can redistribute it and\/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 3\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\/\n\npackage org.fdroid.fdroid.receiver;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.data.ApkProvider;\nimport org.fdroid.fdroid.data.AppProvider;\n\nabstract class PackageReceiver extends BroadcastReceiver {\n\n    private static final String TAG = \"PackageReceiver\";\n\n    protected abstract boolean toDiscard(Intent intent);\n\n    protected abstract void handle(Context context, String appId);\n\n    protected PackageInfo getPackageInfo(Context context, String appId) {\n        PackageInfo info = null;\n        try {\n            info = context.getPackageManager().getPackageInfo(appId, 0);\n        } catch (PackageManager.NameNotFoundException e) {\n            \/\/ ignore\n        }\n        return info;\n    }\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        Utils.debugLog(TAG, \"PackageReceiver received [action = '\" + intent.getAction() + \"', data = '\" + intent.getData() + \"']\");\n        if (toDiscard(intent)) {\n            return;\n        }\n        String appId = intent.getData().getSchemeSpecificPart();\n        handle(context, appId);\n        context.getContentResolver().notifyChange(AppProvider.getContentUri(appId), null);\n        context.getContentResolver().notifyChange(ApkProvider.getAppUri(appId), null);\n    }\n\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the code to improve execution time. Write the entire code and no other text in the response.\n\n### Concepts:\n[hint] reduce timeout\n[hint] by 5 units\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.content.Context;\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\nimport com.aaronjwood.portauthority.utils.UserPreference;\n\nimport java.lang.ref.WeakReference;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n    private final WeakReference<HostAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        HostAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            Context context = (Context) activity;\n            final int NUM_THREADS = UserPreference.getPortScanThreads(context);\n\n            try {\n                InetAddress address = InetAddress.getByName(ip);\n                ip = address.getHostAddress();\n            } catch (UnknownHostException e) {\n                activity.processFinish(false);\n                return null;\n            }\n\n            ExecutorService executor = Executors.newCachedThreadPool();\n\n            int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n            int previousStart = startPort;\n            int previousStop = (startPort - 1) + chunk;\n\n            for (int i = 0; i < NUM_THREADS; i++) {\n                if (previousStop >= stopPort) {\n                    previousStop = stopPort;\n                    executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                    break;\n                }\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                previousStart = previousStop + 1;\n                previousStop = previousStop + chunk;\n            }\n\n            executor.shutdown();\n\n            try {\n                executor.awaitTermination(10, TimeUnit.MINUTES);\n            } catch (InterruptedException ignored) {\n            }\n\n            activity.processFinish(true);\n        }\n\n        return null;\n    }\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.async;\n\nimport android.content.Context;\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\nimport com.aaronjwood.portauthority.utils.UserPreference;\n\nimport java.lang.ref.WeakReference;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n    private final WeakReference<HostAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        HostAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            Context context = (Context) activity;\n            final int NUM_THREADS = UserPreference.getPortScanThreads(context);\n\n            try {\n                InetAddress address = InetAddress.getByName(ip);\n                ip = address.getHostAddress();\n            } catch (UnknownHostException e) {\n                activity.processFinish(false);\n                return null;\n            }\n\n            ExecutorService executor = Executors.newCachedThreadPool();\n\n            int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n            int previousStart = startPort;\n            int previousStop = (startPort - 1) + chunk;\n\n            for (int i = 0; i < NUM_THREADS; i++) {\n                if (previousStop >= stopPort) {\n                    previousStop = stopPort;\n                    executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                    break;\n                }\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                previousStart = previousStop + 1;\n                previousStop = previousStop + chunk;\n            }\n\n            executor.shutdown();\n\n            try {\n                executor.awaitTermination(9, TimeUnit.MINUTES); \/\/ Reduced timeout by 5 units\n            } catch (InterruptedException ignored) {\n            }\n\n            activity.processFinish(true);\n        }\n\n        return null;\n    }\n}\n```"]}
{"non_functional_requirement":"framerate","commit":"https:\/\/github.com\/erikusaj\/fdroidTvClient\/commit\/26b35723d30b5d9e5b7fddfdacbcb475db2da0bb","commit_message":"'\\\\\"use AsyncTask for SwapType operations to run in background\\\\n\\\\nThread runs at normal priority by default.  AsyncTasks are integrated into\\\\nAndroid for handling things running in the background while keeping the UI\\\\nresponsive.\\\\n\\\\nThis reverts most of commit 828cc272ee5235f868104b009349cc7e835e144f.\\\\n\\\\\"'","source_code":"package org.fdroid.fdroid.localrepo.type;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.support.annotation.NonNull;\nimport android.support.v4.content.LocalBroadcastManager;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.localrepo.SwapService;\n\n\/**\n * There is lots of common functionality, and a common API among different communication protocols\n * associated with the swap process. This includes Bluetooth visability, Bonjour visability,\n * and the web server which serves info for swapping. This class provides a common API for\n * starting and stopping these services. In addition, it helps with the process of sending broadcast\n * intents in response to the thing starting or stopping.\n *\/\npublic abstract class SwapType {\n\n    private static final String TAG = \"SwapType\";\n\n    private boolean isConnected;\n\n    @NonNull\n    protected final Context context;\n\n    public SwapType(@NonNull Context context) {\n        this.context = context;\n    }\n\n    public abstract void start();\n\n    public abstract void stop();\n\n    protected abstract String getBroadcastAction();\n\n    public boolean isDiscoverable() {\n        return isConnected();\n    }\n\n    protected final void setConnected(boolean connected) {\n        if (connected) {\n            isConnected = true;\n            sendBroadcast(SwapService.EXTRA_STARTED);\n        } else {\n            isConnected = false;\n            onStopped();\n            sendBroadcast(SwapService.EXTRA_STOPPED);\n        }\n    }\n\n    protected void onStopped() { }\n\n    \/**\n     * Sends either a {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STARTING},\n     * {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STARTED} or\n     * {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STOPPED} broadcast.\n     *\/\n    protected final void sendBroadcast(String extra) {\n        if (getBroadcastAction() != null) {\n            Intent intent = new Intent(getBroadcastAction());\n            intent.putExtra(extra, true);\n            Utils.debugLog(TAG, \"Sending broadcast \" + extra + \" from \" + getClass().getSimpleName());\n            LocalBroadcastManager.getInstance(context).sendBroadcast(intent);\n        }\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public void startInBackground() {\n        new Thread() {\n            @Override\n            public void run() {\n                SwapType.this.start();\n            }\n        }.start();\n    }\n\n    private void ensureRunning() {\n        if (!isConnected()) {\n            start();\n        }\n    }\n\n    public void ensureRunningInBackground() {\n        new Thread() {\n            @Override\n            public void run() {\n                ensureRunning();\n            }\n        }.start();\n    }\n\n    public void stopInBackground() {\n        new Thread() {\n            @Override\n            public void run() {\n                SwapType.this.stop();\n            }\n        }.start();\n    }\n\n}\n","target_code":"package org.fdroid.fdroid.localrepo.type;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.AsyncTask;\nimport android.support.annotation.NonNull;\nimport android.support.v4.content.LocalBroadcastManager;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.localrepo.SwapService;\n\n\/**\n * There is lots of common functionality, and a common API among different communication protocols\n * associated with the swap process. This includes Bluetooth visability, Bonjour visability,\n * and the web server which serves info for swapping. This class provides a common API for\n * starting and stopping these services. In addition, it helps with the process of sending broadcast\n * intents in response to the thing starting or stopping.\n *\/\npublic abstract class SwapType {\n\n    private static final String TAG = \"SwapType\";\n\n    private boolean isConnected;\n\n    @NonNull\n    protected final Context context;\n\n    public SwapType(@NonNull Context context) {\n        this.context = context;\n    }\n\n    public abstract void start();\n\n    public abstract void stop();\n\n    protected abstract String getBroadcastAction();\n\n    public boolean isDiscoverable() {\n        return isConnected();\n    }\n\n    protected final void setConnected(boolean connected) {\n        if (connected) {\n            isConnected = true;\n            sendBroadcast(SwapService.EXTRA_STARTED);\n        } else {\n            isConnected = false;\n            onStopped();\n            sendBroadcast(SwapService.EXTRA_STOPPED);\n        }\n    }\n\n    protected void onStopped() { }\n\n    \/**\n     * Sends either a {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STARTING},\n     * {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STARTED} or\n     * {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STOPPED} broadcast.\n     *\/\n    protected final void sendBroadcast(String extra) {\n        if (getBroadcastAction() != null) {\n            Intent intent = new Intent(getBroadcastAction());\n            intent.putExtra(extra, true);\n            Utils.debugLog(TAG, \"Sending broadcast \" + extra + \" from \" + getClass().getSimpleName());\n            LocalBroadcastManager.getInstance(context).sendBroadcast(intent);\n        }\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public void startInBackground() {\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                start();\n                return null;\n            }\n        }.execute();\n    }\n\n    private void ensureRunning() {\n        if (!isConnected()) {\n            start();\n        }\n    }\n\n    public void ensureRunningInBackground() {\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                ensureRunning();\n                return null;\n            }\n        }.execute();\n    }\n\n    public void stopInBackground() {\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... params) {\n                stop();\n                return null;\n            }\n        }.execute();\n    }\n\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage me.rosuh.easywatermark.widget\n\nimport android.animation.ObjectAnimator\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.graphics.*\nimport android.util.AttributeSet\nimport androidx.appcompat.widget.AppCompatImageView\nimport androidx.core.graphics.drawable.toBitmap\n\n\nclass ColoredImageVIew : AppCompatImageView {\n    constructor(context: Context) : super(context)\n    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    )\n\n    private var sizeHasChanged: Boolean = true\n    private val paint by lazy { Paint() }\n\n    private val colorList = arrayOf(\n        Color.parseColor(\"#FFA51F\"),\n        Color.parseColor(\"#FFD703\"),\n        Color.parseColor(\"#C0FF39\"),\n        Color.parseColor(\"#00FFE0\")\n    ).toIntArray()\n\n    private val posList = arrayOf(0f, 0.5178f, 0.7654f, 1f).toFloatArray()\n\n    private val xfermode by lazy { PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP) }\n\n    private val colorAnimator by lazy {\n        ObjectAnimator.ofFloat(1f, 0f)\n            .apply {\n                addUpdateListener {\n                    val pos = (it.animatedValue as Float)\n                    val shader = LinearGradient(\n                        (1 - pos) * width.toFloat() * 2f,\n                        pos * height.toFloat(),\n                        0f,\n                        height.toFloat(),\n                        colorList,\n                        posList,\n                        Shader.TileMode.CLAMP\n                    )\n                    paint.shader = shader\n                    postInvalidateOnAnimation()\n                }\n                duration = 1200\n                repeatCount = ObjectAnimator.INFINITE\n                repeatMode = ObjectAnimator.REVERSE\n            }\n    }\n\n\n    private var innerBitmap: Bitmap? = null\n\n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n        sizeHasChanged = w != oldh || h != oldh\n    }\n\n    @SuppressLint(\"DrawAllocation\")\n    override fun onDraw(canvas: Canvas?) {\n        if (innerBitmap == null || sizeHasChanged) {\n            super.onDraw(canvas)\n            innerBitmap = drawable.toBitmap(width, height)\n        }\n        innerBitmap?.let {\n            val sc = canvas?.saveLayer(0f, 0f, width.toFloat(), height.toFloat(), null) ?: return\n            canvas.drawBitmap(it, 0f, 0f, paint)\n            paint.xfermode = xfermode\n            canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint)\n            paint.xfermode = null\n            canvas.restoreToCount(sc)\n        }\n    }\n\n\n    fun start() {\n        colorAnimator.start()\n    }\n\n    fun stop() {\n        colorAnimator.pause()\n    }\n}\n\nCode-B:\npackage me.rosuh.easywatermark.widget\n\nimport android.animation.ObjectAnimator\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.graphics.*\nimport android.util.AttributeSet\nimport androidx.appcompat.widget.AppCompatImageView\nimport androidx.core.graphics.drawable.toBitmap\nimport androidx.interpolator.view.animation.FastOutLinearInInterpolator\n\n\nclass ColoredImageVIew : AppCompatImageView {\n    constructor(context: Context) : super(context)\n    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    )\n\n    private val paint by lazy { Paint() }\n\n    private val colorList = arrayOf(\n        Color.parseColor(\"#FFA51F\"),\n        Color.parseColor(\"#FFD703\"),\n        Color.parseColor(\"#C0FF39\"),\n        Color.parseColor(\"#00FFE0\")\n    ).toIntArray()\n\n    private val posList = arrayOf(0f, 0.5178f, 0.7654f, 1f).toFloatArray()\n\n    private val colorAnimator by lazy {\n        ObjectAnimator.ofFloat(1f, 0f)\n            .apply {\n                addUpdateListener {\n                    val pos = (it.animatedValue as Float)\n                    val shader = LinearGradient(\n                        (1 - pos) * width.toFloat() * 2f,\n                        pos * height.toFloat(),\n                        0f,\n                        height.toFloat(),\n                        colorList,\n                        posList,\n                        Shader.TileMode.CLAMP\n                    )\n                    paint.shader = shader\n                    postInvalidateOnAnimation()\n                }\n                duration = 1200\n                interpolator = FastOutLinearInInterpolator()\n                repeatCount = ObjectAnimator.INFINITE\n                repeatMode = ObjectAnimator.REVERSE\n            }\n    }\n\n\n    private var innerBitmap: Bitmap? = null\n\n    @SuppressLint(\"DrawAllocation\")\n    override fun onDraw(canvas: Canvas?) {\n        if (innerBitmap == null) {\n            super.onDraw(canvas)\n            innerBitmap = drawable.toBitmap(width, height)\n        }\n        innerBitmap?.let {\n            val sc = canvas?.saveLayer(0f, 0f, width.toFloat(), height.toFloat(), null) ?: return\n            canvas.drawBitmap(it, 0f, 0f, paint)\n            paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP)\n            canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint)\n            paint.xfermode = null\n            canvas.restoreToCount(sc)\n        }\n    }\n\n\n    fun start() {\n        colorAnimator.start()\n    }\n\n    fun stop() {\n        colorAnimator.pause()\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage me.rosuh.easywatermark.widget\n\nimport android.animation.ObjectAnimator\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.graphics.*\nimport android.util.AttributeSet\nimport androidx.appcompat.widget.AppCompatImageView\nimport androidx.core.graphics.drawable.toBitmap\nimport androidx.interpolator.view.animation.FastOutLinearInInterpolator\n\n\nclass ColoredImageVIew : AppCompatImageView {\n    constructor(context: Context) : super(context)\n    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    )\n\n    private val paint by lazy { Paint() }\n\n    private val colorList = arrayOf(\n        Color.parseColor(\"#FFA51F\"),\n        Color.parseColor(\"#FFD703\"),\n        Color.parseColor(\"#C0FF39\"),\n        Color.parseColor(\"#00FFE0\")\n    ).toIntArray()\n\n    private val posList = arrayOf(0f, 0.5178f, 0.7654f, 1f).toFloatArray()\n\n    private val colorAnimator by lazy {\n        ObjectAnimator.ofFloat(1f, 0f)\n            .apply {\n                addUpdateListener {\n                    val pos = (it.animatedValue as Float)\n                    val shader = LinearGradient(\n                        (1 - pos) * width.toFloat() * 2f,\n                        pos * height.toFloat(),\n                        0f,\n                        height.toFloat(),\n                        colorList,\n                        posList,\n                        Shader.TileMode.CLAMP\n                    )\n                    paint.shader = shader\n                    postInvalidateOnAnimation()\n                }\n                duration = 1200\n                interpolator = FastOutLinearInInterpolator()\n                repeatCount = ObjectAnimator.INFINITE\n                repeatMode = ObjectAnimator.REVERSE\n            }\n    }\n\n\n    private var innerBitmap: Bitmap? = null\n\n    @SuppressLint(\"DrawAllocation\")\n    override fun onDraw(canvas: Canvas?) {\n        if (innerBitmap == null) {\n            super.onDraw(canvas)\n            innerBitmap = drawable.toBitmap(width, height)\n        }\n        innerBitmap?.let {\n            val sc = canvas?.saveLayer(0f, 0f, width.toFloat(), height.toFloat(), null) ?: return\n            canvas.drawBitmap(it, 0f, 0f, paint)\n            paint.xfermode = PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP)\n            canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint)\n            paint.xfermode = null\n            canvas.restoreToCount(sc)\n        }\n    }\n\n\n    fun start() {\n        colorAnimator.start()\n    }\n\n    fun stop() {\n        colorAnimator.pause()\n    }\n}\n\nCode-B:\npackage me.rosuh.easywatermark.widget\n\nimport android.animation.ObjectAnimator\nimport android.annotation.SuppressLint\nimport android.content.Context\nimport android.graphics.*\nimport android.util.AttributeSet\nimport androidx.appcompat.widget.AppCompatImageView\nimport androidx.core.graphics.drawable.toBitmap\n\n\nclass ColoredImageVIew : AppCompatImageView {\n    constructor(context: Context) : super(context)\n    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs)\n    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(\n        context,\n        attrs,\n        defStyleAttr\n    )\n\n    private var sizeHasChanged: Boolean = true\n    private val paint by lazy { Paint() }\n\n    private val colorList = arrayOf(\n        Color.parseColor(\"#FFA51F\"),\n        Color.parseColor(\"#FFD703\"),\n        Color.parseColor(\"#C0FF39\"),\n        Color.parseColor(\"#00FFE0\")\n    ).toIntArray()\n\n    private val posList = arrayOf(0f, 0.5178f, 0.7654f, 1f).toFloatArray()\n\n    private val xfermode by lazy { PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP) }\n\n    private val colorAnimator by lazy {\n        ObjectAnimator.ofFloat(1f, 0f)\n            .apply {\n                addUpdateListener {\n                    val pos = (it.animatedValue as Float)\n                    val shader = LinearGradient(\n                        (1 - pos) * width.toFloat() * 2f,\n                        pos * height.toFloat(),\n                        0f,\n                        height.toFloat(),\n                        colorList,\n                        posList,\n                        Shader.TileMode.CLAMP\n                    )\n                    paint.shader = shader\n                    postInvalidateOnAnimation()\n                }\n                duration = 1200\n                repeatCount = ObjectAnimator.INFINITE\n                repeatMode = ObjectAnimator.REVERSE\n            }\n    }\n\n\n    private var innerBitmap: Bitmap? = null\n\n    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {\n        super.onSizeChanged(w, h, oldw, oldh)\n        sizeHasChanged = w != oldh || h != oldh\n    }\n\n    @SuppressLint(\"DrawAllocation\")\n    override fun onDraw(canvas: Canvas?) {\n        if (innerBitmap == null || sizeHasChanged) {\n            super.onDraw(canvas)\n            innerBitmap = drawable.toBitmap(width, height)\n        }\n        innerBitmap?.let {\n            val sc = canvas?.saveLayer(0f, 0f, width.toFloat(), height.toFloat(), null) ?: return\n            canvas.drawBitmap(it, 0f, 0f, paint)\n            paint.xfermode = xfermode\n            canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), paint)\n            paint.xfermode = null\n            canvas.restoreToCount(sc)\n        }\n    }\n\n\n    fun start() {\n        colorAnimator.start()\n    }\n\n    fun stop() {\n        colorAnimator.pause()\n    }\n}\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite the code to improve frame rate and user experience of the android application. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] android.os.AsyncTask\n[-] Thread\n\n### Given program:\n```java\npackage org.fdroid.fdroid.localrepo.type;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.support.annotation.NonNull;\nimport android.support.v4.content.LocalBroadcastManager;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.localrepo.SwapService;\n\n\/**\n * There is lots of common functionality, and a common API among different communication protocols\n * associated with the swap process. This includes Bluetooth visability, Bonjour visability,\n * and the web server which serves info for swapping. This class provides a common API for\n * starting and stopping these services. In addition, it helps with the process of sending broadcast\n * intents in response to the thing starting or stopping.\n *\/\npublic abstract class SwapType {\n\n    private static final String TAG = \"SwapType\";\n\n    private boolean isConnected;\n\n    @NonNull\n    protected final Context context;\n\n    public SwapType(@NonNull Context context) {\n        this.context = context;\n    }\n\n    public abstract void start();\n\n    public abstract void stop();\n\n    protected abstract String getBroadcastAction();\n\n    public boolean isDiscoverable() {\n        return isConnected();\n    }\n\n    protected final void setConnected(boolean connected) {\n        if (connected) {\n            isConnected = true;\n            sendBroadcast(SwapService.EXTRA_STARTED);\n        } else {\n            isConnected = false;\n            onStopped();\n            sendBroadcast(SwapService.EXTRA_STOPPED);\n        }\n    }\n\n    protected void onStopped() { }\n\n    \/**\n     * Sends either a {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STARTING},\n     * {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STARTED} or\n     * {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STOPPED} broadcast.\n     *\/\n    protected final void sendBroadcast(String extra) {\n        if (getBroadcastAction() != null) {\n            Intent intent = new Intent(getBroadcastAction());\n            intent.putExtra(extra, true);\n            Utils.debugLog(TAG, \"Sending broadcast \" + extra + \" from \" + getClass().getSimpleName());\n            LocalBroadcastManager.getInstance(context).sendBroadcast(intent);\n        }\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public void startInBackground() {\n        new Thread() {\n            @Override\n            public void run() {\n                SwapType.this.start();\n            }\n        }.start();\n    }\n\n    private void ensureRunning() {\n        if (!isConnected()) {\n            start();\n        }\n    }\n\n    public void ensureRunningInBackground() {\n        new Thread() {\n            @Override\n            public void run() {\n                ensureRunning();\n            }\n        }.start();\n    }\n\n    public void stopInBackground() {\n        new Thread() {\n            @Override\n            public void run() {\n                SwapType.this.stop();\n            }\n        }.start();\n    }\n\n}\n\n```\n\n### Response:\n```java\n```java\npackage org.fdroid.fdroid.localrepo.type;\n\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.AsyncTask;\nimport android.support.annotation.NonNull;\nimport android.support.v4.content.LocalBroadcastManager;\n\nimport org.fdroid.fdroid.Utils;\nimport org.fdroid.fdroid.localrepo.SwapService;\n\n\/**\n * There is lots of common functionality, and a common API among different communication protocols\n * associated with the swap process. This includes Bluetooth visibility, Bonjour visibility,\n * and the web server which serves info for swapping. This class provides a common API for\n * starting and stopping these services. In addition, it helps with the process of sending broadcast\n * intents in response to the thing starting or stopping.\n *\/\npublic abstract class SwapType {\n\n    private static final String TAG = \"SwapType\";\n\n    private boolean isConnected;\n\n    @NonNull\n    protected final Context context;\n\n    public SwapType(@NonNull Context context) {\n        this.context = context;\n    }\n\n    public abstract void start();\n\n    public abstract void stop();\n\n    protected abstract String getBroadcastAction();\n\n    public boolean isDiscoverable() {\n        return isConnected();\n    }\n\n    protected final void setConnected(boolean connected) {\n        if (connected) {\n            isConnected = true;\n            sendBroadcast(SwapService.EXTRA_STARTED);\n        } else {\n            isConnected = false;\n            onStopped();\n            sendBroadcast(SwapService.EXTRA_STOPPED);\n        }\n    }\n\n    protected void onStopped() { }\n\n    \/**\n     * Sends either a {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STARTING},\n     * {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STARTED} or\n     * {@link org.fdroid.fdroid.localrepo.SwapService#EXTRA_STOPPED} broadcast.\n     *\/\n    protected final void sendBroadcast(String extra) {\n        if (getBroadcastAction() != null) {\n            Intent intent = new Intent(getBroadcastAction());\n            intent.putExtra(extra, true);\n            Utils.debugLog(TAG, \"Sending broadcast \" + extra + \" from \" + getClass().getSimpleName());\n            LocalBroadcastManager.getInstance(context).sendBroadcast(intent);\n        }\n    }\n\n    public boolean isConnected() {\n        return isConnected;\n    }\n\n    public void startInBackground() {\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... voids) {\n                SwapType.this.start();\n                return null;\n            }\n        }.execute();\n    }\n\n    private void ensureRunning() {\n        if (!isConnected()) {\n            start();\n        }\n    }\n\n    public void ensureRunningInBackground() {\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... voids) {\n                ensureRunning();\n                return null;\n            }\n        }.execute();\n    }\n\n    public void stopInBackground() {\n        new AsyncTask<Void, Void, Void>() {\n            @Override\n            protected Void doInBackground(Void... voids) {\n                SwapType.this.stop();\n                return null;\n            }\n        }.execute();\n    }\n\n}\n```"]}
{"non_functional_requirement":"executiontime","commit":"https:\/\/github.com\/aaronjwood\/PortAuthority\/commit\/44a588294f7ab129eb50de23897a348e114fc30b","commit_message":"'\\\\\"Set performance options to prefer fast connection when scanning ports. Enable TCP_NODELAY\\\\n\\\\\"'","source_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(1);\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n\n                char[] buffer = new char[1024];\n                HashMap<Integer, String> portData = new HashMap<>();\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String data = null;\n\n                if(i == 22) {\n                    data = in.readLine();\n                    in.close();\n                }\n                else if(i == 80 || i == 443) {\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\");\n                    out.println(\"Host: \" + this.ip);\n                    out.println(\"\");\n\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if(data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    }\n                    else if(data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    }\n                    else if(data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    }\n                    else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            }\n            catch(IOException ignored) {\n            }\n        }\n    }\n}\n","target_code":"package com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(1);\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.setPerformancePreferences(1, 0, 0);\n                socket.setTcpNoDelay(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n\n                char[] buffer = new char[1024];\n                HashMap<Integer, String> portData = new HashMap<>();\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String data = null;\n\n                if(i == 22) {\n                    data = in.readLine();\n                    in.close();\n                }\n                else if(i == 80 || i == 443) {\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\");\n                    out.println(\"Host: \" + this.ip);\n                    out.println(\"\");\n\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if(data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    }\n                    else if(data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    }\n                    else if(data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    }\n                    else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            }\n            catch(IOException ignored) {\n            }\n        }\n    }\n}\n","pl":"Java","classification_left_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.async;\n\nimport android.content.Context;\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\nimport com.aaronjwood.portauthority.utils.UserPreference;\n\nimport java.lang.ref.WeakReference;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n    private final WeakReference<HostAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        HostAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            Context context = (Context) activity;\n            final int NUM_THREADS = UserPreference.getPortScanThreads(context);\n\n            try {\n                InetAddress address = InetAddress.getByName(ip);\n                ip = address.getHostAddress();\n            } catch (UnknownHostException e) {\n                activity.processFinish(false);\n                return null;\n            }\n\n            ExecutorService executor = Executors.newCachedThreadPool();\n\n            int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n            int previousStart = startPort;\n            int previousStop = (startPort - 1) + chunk;\n\n            for (int i = 0; i < NUM_THREADS; i++) {\n                if (previousStop >= stopPort) {\n                    previousStop = stopPort;\n                    executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                    break;\n                }\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                previousStart = previousStop + 1;\n                previousStop = previousStop + chunk;\n            }\n\n            executor.shutdown();\n\n            try {\n                executor.awaitTermination(5, TimeUnit.MINUTES);\n            } catch (InterruptedException ignored) {\n            }\n\n            activity.processFinish(true);\n        }\n\n        return null;\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.async;\n\nimport android.content.Context;\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\nimport com.aaronjwood.portauthority.utils.UserPreference;\n\nimport java.lang.ref.WeakReference;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n    private final WeakReference<HostAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        HostAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            Context context = (Context) activity;\n            final int NUM_THREADS = UserPreference.getPortScanThreads(context);\n\n            try {\n                InetAddress address = InetAddress.getByName(ip);\n                ip = address.getHostAddress();\n            } catch (UnknownHostException e) {\n                activity.processFinish(false);\n                return null;\n            }\n\n            ExecutorService executor = Executors.newCachedThreadPool();\n\n            int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n            int previousStart = startPort;\n            int previousStop = (startPort - 1) + chunk;\n\n            for (int i = 0; i < NUM_THREADS; i++) {\n                if (previousStop >= stopPort) {\n                    previousStop = stopPort;\n                    executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                    break;\n                }\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                previousStart = previousStop + 1;\n                previousStop = previousStop + chunk;\n            }\n\n            executor.shutdown();\n\n            try {\n                executor.awaitTermination(10, TimeUnit.MINUTES);\n            } catch (InterruptedException ignored) {\n            }\n\n            activity.processFinish(true);\n        }\n\n        return null;\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_left_label":"A","classification_right_prompt":"Below is an instruction that describes a task. Write a response that appropriately completes the request.\n### Instruction:\n\nOnly one of the two code snippets has a lower execution time.\n\nCode-A:\npackage com.aaronjwood.portauthority.async;\n\nimport android.content.Context;\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\nimport com.aaronjwood.portauthority.utils.UserPreference;\n\nimport java.lang.ref.WeakReference;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n    private final WeakReference<HostAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        HostAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            Context context = (Context) activity;\n            final int NUM_THREADS = UserPreference.getPortScanThreads(context);\n\n            try {\n                InetAddress address = InetAddress.getByName(ip);\n                ip = address.getHostAddress();\n            } catch (UnknownHostException e) {\n                activity.processFinish(false);\n                return null;\n            }\n\n            ExecutorService executor = Executors.newCachedThreadPool();\n\n            int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n            int previousStart = startPort;\n            int previousStop = (startPort - 1) + chunk;\n\n            for (int i = 0; i < NUM_THREADS; i++) {\n                if (previousStop >= stopPort) {\n                    previousStop = stopPort;\n                    executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                    break;\n                }\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                previousStart = previousStop + 1;\n                previousStop = previousStop + chunk;\n            }\n\n            executor.shutdown();\n\n            try {\n                executor.awaitTermination(10, TimeUnit.MINUTES);\n            } catch (InterruptedException ignored) {\n            }\n\n            activity.processFinish(true);\n        }\n\n        return null;\n    }\n}\n\n\nCode-B:\npackage com.aaronjwood.portauthority.async;\n\nimport android.content.Context;\nimport android.os.AsyncTask;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\nimport com.aaronjwood.portauthority.runnable.ScanPortsRunnable;\nimport com.aaronjwood.portauthority.utils.UserPreference;\n\nimport java.lang.ref.WeakReference;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScanPortsAsyncTask extends AsyncTask<Object, Void, Void> {\n    private final WeakReference<HostAsyncResponse> delegate;\n\n    \/**\n     * Constructor to set the delegate\n     *\n     * @param delegate Called when a port scan has finished\n     *\/\n    public ScanPortsAsyncTask(HostAsyncResponse delegate) {\n        this.delegate = new WeakReference<>(delegate);\n    }\n\n    \/**\n     * Chunks the ports selected for scanning and starts the process\n     * Chunked ports are scanned in parallel\n     *\n     * @param params IP address, start port, and stop port\n     *\/\n    @Override\n    protected Void doInBackground(Object... params) {\n        String ip = (String) params[0];\n        int startPort = (int) params[1];\n        int stopPort = (int) params[2];\n\n        HostAsyncResponse activity = delegate.get();\n        if (activity != null) {\n            Context context = (Context) activity;\n            final int NUM_THREADS = UserPreference.getPortScanThreads(context);\n\n            try {\n                InetAddress address = InetAddress.getByName(ip);\n                ip = address.getHostAddress();\n            } catch (UnknownHostException e) {\n                activity.processFinish(false);\n                return null;\n            }\n\n            ExecutorService executor = Executors.newCachedThreadPool();\n\n            int chunk = (int) Math.ceil((double) (stopPort - startPort) \/ NUM_THREADS);\n            int previousStart = startPort;\n            int previousStop = (startPort - 1) + chunk;\n\n            for (int i = 0; i < NUM_THREADS; i++) {\n                if (previousStop >= stopPort) {\n                    previousStop = stopPort;\n                    executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                    break;\n                }\n                executor.execute(new ScanPortsRunnable(ip, previousStart, previousStop, delegate));\n                previousStart = previousStop + 1;\n                previousStop = previousStop + chunk;\n            }\n\n            executor.shutdown();\n\n            try {\n                executor.awaitTermination(5, TimeUnit.MINUTES);\n            } catch (InterruptedException ignored) {\n            }\n\n            activity.processFinish(true);\n        }\n\n        return null;\n    }\n}\n\n\nPlease select the code snippet from Code-A or Code-B with a lower execution time utilization.\n\n### Response: Code-","classification_right_label":"B","inference_time":17.0675917179,"generated_answers":["Below is an instruction that describes a task. The instruction contains concepts formatted as a list of keyword and value pairs separated by newline. The list of concept keywords and their descriptions are:\n\n### Keywords:\n\n[in] What specific function or class to focus on to implement the required change(s).\n\n[+] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to USE or ADD to implement the required change(s)\n\n[-] What specific library, programming or data structure or design concept, or programmer-defined construct in the code to NOT USE or REMOVE to implement the required change(s)\n\n[implement] What specific function to implement in the class of interest\n\n[override] What specific function of the parent class to override and implement in the class of interest\n\n[hint] Full or partial textual description of the idea to implement\n\nWrite a response that appropriately completes the request.\n\n### Instruction:\nRewrite code to prefer fast connection when scanning ports. Write the entire code and no other text in the response.\n\n### Concepts:\n[+] TCP_NODELAY\n[+] setPerformancePreferences\n\n### Given program:\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(1);\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n\n                char[] buffer = new char[1024];\n                HashMap<Integer, String> portData = new HashMap<>();\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String data = null;\n\n                if(i == 22) {\n                    data = in.readLine();\n                    in.close();\n                }\n                else if(i == 80 || i == 443) {\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\");\n                    out.println(\"Host: \" + this.ip);\n                    out.println(\"\");\n\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if(data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    }\n                    else if(data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    }\n                    else if(data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    }\n                    else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            }\n            catch(IOException ignored) {\n            }\n        }\n    }\n}\n\n```\n\n### Response:\n```java\n```java\npackage com.aaronjwood.portauthority.runnable;\n\nimport com.aaronjwood.portauthority.response.HostAsyncResponse;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.HashMap;\n\npublic class ScanPortsRunnable implements Runnable {\n\n    private static final String TAG = \"ScanPortsRunnable\";\n\n    private String ip;\n    private int startPort;\n    private int stopPort;\n    private HostAsyncResponse delegate;\n\n    \/**\n     * Constructor to set the necessary data to perform a port scan\n     *\n     * @param ip        IP address\n     * @param startPort Port to start scanning at\n     * @param stopPort  Port to stop scanning at\n     * @param delegate  Called when this chunk of ports has finished scanning\n     *\/\n    public ScanPortsRunnable(String ip, int startPort, int stopPort, HostAsyncResponse delegate) {\n        this.ip = ip;\n        this.startPort = startPort;\n        this.stopPort = stopPort;\n        this.delegate = delegate;\n    }\n\n    \/**\n     * Starts the port scan\n     *\/\n    @Override\n    public void run() {\n        for(int i = this.startPort; i <= this.stopPort; i++) {\n            try {\n                this.delegate.processFinish(1);\n                Socket socket = new Socket();\n                socket.setReuseAddress(true);\n                socket.setPerformancePreferences(1, 0, 0); \/\/ Prefer fast connection\n                socket.connect(new InetSocketAddress(this.ip, i), 3500);\n\n                char[] buffer = new char[1024];\n                HashMap<Integer, String> portData = new HashMap<>();\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                String data = null;\n\n                if(i == 22) {\n                    data = in.readLine();\n                    in.close();\n                }\n                else if(i == 80 || i == 443) {\n                    PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                    out.println(\"GET \/ HTTP\/1.1\");\n                    out.println(\"Host: \" + this.ip);\n                    out.println(\"\");\n\n                    in.read(buffer, 0, 1024);\n                    out.close();\n                    in.close();\n                    data = new String(buffer).toLowerCase();\n                    if(data.contains(\"apache\") || data.contains(\"httpd\")) {\n                        data = \"Apache\";\n                    }\n                    else if(data.contains(\"iis\") || data.contains(\"microsoft\")) {\n                        data = \"IIS\";\n                    }\n                    else if(data.contains(\"nginx\")) {\n                        data = \"Nginx\";\n                    }\n                    else {\n                        data = null;\n                    }\n                }\n\n                portData.put(i, data);\n                socket.close();\n\n                this.delegate.processFinish(portData);\n            }\n            catch(IOException ignored) {\n            }\n        }\n    }\n}\n```"]}